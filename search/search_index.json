{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Col\u00b7lecci\u00f3 d'algunes pr\u00e0ctiques del m\u00f2dul de seguretat i alta disponibilitat (SAD), de 2n d'ASIX.</p> <p>Colecci\u00f3n de algunas pr\u00e1cticas y apuntes del m\u00f3dulo de seguridad y alta disponibilidad (SAD), de 2\u00ba de ASIR.</p>"},{"location":"ARP_Spoofing/","title":"ARP Spoofing","text":""},{"location":"ARP_Spoofing/#docker","title":"Docker","text":"<p>https://raul-profesor.github.io/DEAW/introduction/</p> <p>https://kinsta.com/es/base-de-conocimiento/que-es-docker/</p> <p>https://datascientest.com/es/docker-todo-que-saber</p> <p>https://www.ibm.com/topics/docker</p> <p>Tarea 0<p>Deb\u00e9is instalar Docker en Kali o Ubuntu. Pod\u00e9is ayudaros del material que consider\u00e9is, como por ejemplo este o cualquier otro.</p> </p>"},{"location":"ARP_Spoofing/#arp","title":"ARP","text":"<p>Cuando una m\u00e1quina necesita comunicarse con otra en una red, necesita conocer en primera instancia su IP para poder enviar el paquete a su destino, pero en capa 2 de OSI, utiliza direcciones MAC. El protocolo ARP entra en juego en este momento, dado que env\u00eda los mensajes pertinentes para averiguar la direcci\u00f3n MAC asociada a una IP concreta.</p> <p></p> <p>Cuando un dispositivo desea enviar paquetes a otro, lanza un mensaje broadcast ARP preguntando en la red qu\u00e9 disposito posee esa IP concreta y esperando una respuesta \u00fanicamente de ese dispositivo identific\u00e1ndose y, adem\u00e1s, enviando su MAC.</p> <p></p> <p>De esta forma, los dispositivos en la red van construyendo sus tablas ARP, donde cada entrada hace corresponder una IP con su MAC, de tal forma que si tuvieran que volver a enviar mensajes a esas m\u00e1quinas, ya no necesitan pasar por el proceso de averig\u00fcaci\u00f3n de direcciones MAC.</p> <p></p>"},{"location":"ARP_Spoofing/#arp-spoofing_1","title":"ARP Spoofing","text":"<p>Este ataque es de los conocidos como tipo Man in the Middle, llamados as\u00ed porque consisten en que un atacante o actor malicioso se interpone entre la comnicaci\u00f3n de dos v\u00edctimas, actuando de intermediario sin que ellas se den cuenta. Esto le permite interceptar toda la comunicaci\u00f3n, pudiendo espiarla o incluso modificarla, si as\u00ed lo desea.</p> <p>En el caso de un ARP Spoofing, el atacant env\u00eda falsos mensajes de respuesta ARP, indicando que su MAC se corresponde con otra IP, la de la v\u00edctima y as\u00ed recibir los mensajes que van destinados a ella.</p> <p></p>"},{"location":"ARP_Spoofing/#realizacion-de-la-practica","title":"Realizaci\u00f3n de la pr\u00e1ctica","text":"<p>Deb\u00e9is clonar el repositorio: https://github.com/raul-profesor/spoofing</p> <p>Esta pr\u00e1ctica est\u00e1 ubicada dentro de la carpeta <code>Lab1-ArpSpoofing</code>.</p> <p>Vamos a crear la siguiente infraestructura:</p> <p> </p> <p>Que consiste en:</p> <ul> <li>Dos contenedores v\u00edctimas</li> <li>Un atacante</li> <li>Un observador TcpDumper cuya \u00fanica funci\u00f3n es escuchar el tr\u00e1fico de la red</li> </ul> <p>Pasemos a construir las im\u00e1genes que m\u00e1s tarde dar\u00e1n lugar a los contenedores del atacante y del TcpDumper que vamos a ejecutar. Para este cometido no ten\u00e9is m\u00e1s que ejecutar el <code>script build.sh</code>. Los contenedores v\u00edctimas son simplemente im\u00e1genes de busybox sin modificar, directamente del \"registry\" de Docker.</p> <p>Ahora ejecutaremos los 4 contenedores, cada uno en una pesta\u00f1a distinta del terminal:</p> <pre><code>docker run -it --rm --name box1 busybox\ndocker run -it --rm --name box2 busybox\ndocker run -it --rm --name arpspoofer arpspoofer\ndocker run -it --rm  --net=container:arpspoofer --name tcpdumper tcpdumper\n</code></pre> <p>Tarea 1</p> <ul> <li>Comprueba las IPs y las MAC de box1, box2 y arpspoofer con <code>ip a</code></li> <li>Comprueba la tabla ARP de box1 con <code>watch ip neigh</code></li> <li>Realiza un ping de box2 a box1 y mantenlo</li> <li>En el contenedor del <code>arpspoofer</code> comienza el spoofeo: <code>/usr/sbin/arpspoof -r -i eth0 -t x.x.x.x y.y.y.y</code> (IPs de box1 y 2)</li> </ul> <p>Tras los pasos anteriores deberias empezar a ver el tr\u00e1fico capturado por el contenedor TcpDumper.</p> <p>Tarea 2</p> <p>Adem\u00e1s del tcpdump del contenedor TcpDumper pon a capturar tr\u00e1fico con Wireshark en la interfaz <code>Docker0</code> de la m\u00e1quina anfitri\u00f3n.</p> <p>Tarea 3</p> <p>Describe detalladamente qu\u00e9 observas que est\u00e1 ocurriendo en la captura del contenedor <code>TcpDumper</code></p> <p>Tarea 4</p> <p>\u00bfC\u00f3mo podemos tener una pista de lo que est\u00e1 ocurriendo mirando s\u00f3lamente el <code>ping</code> que hemos lanzado al principio?</p> <p>Tarea 5</p> <p>En la captura de TCPDump, indica y explica detalladamente:     + Mensajes ARP donde se ve claramente qu\u00e9 est\u00e1 ocurriendo y cu\u00e1l es el ataque, ind\u00edca expl\u00edcitamente los mensajes.     + Mensajes ICMP donde se ve la secuencia de los acontecimienntos.</p> <p>Tarea 6</p> <p>En la captura de Wireshark filtra por el protocolo ICMP y repite las explicaciones de la Tarea 5.</p> <p>Tarea 7<p>Realiza un diagrama en https://www.drawio.com/ donde expliques claramente de forma gr\u00e1fica el proceso que has llevado a acabo.</p> </p>"},{"location":"fw-ics/","title":"Administraci\u00f3 de regles d'iptables en un entorn industrial","text":""},{"location":"fw-ics/#introduccio","title":"Introducci\u00f3","text":"<p>Atenci\u00f3!</p> <p>Heu de fer servir el laboratori de Labtrainer <code>iptables-ics</code></p> <p>Este laboratori simula l'\u00fas de Iptables per a limitar l'acc\u00e9s a la xarxa d'un component PLC en un entorn indistrial o de tecnolog\u00eda operativa.</p> <p>L'escenari concret s'il\u00b7lustra en la seg\u00fcent imatge:</p> <p></p> <p>Quan la configuraci\u00f3 \u00e9s correcta:</p> <ul> <li>El client 1 nom\u00e9s pot accedir al PLC via SSH i HTTP (port 8080)</li> <li>El client 2 nom\u00e9s pot accedir al PLC mitjan\u00e7ant MODBUS TCP i HTTP (ports 80 i 8080)</li> </ul>"},{"location":"fw-ics/#realitzacio-del-laboratori","title":"Realitzaci\u00f3 del laboratori","text":"<p>Inicieu el laboratori com ja sabeu</p> <pre><code>labtainer iptables-ics\n</code></pre> <p>I espereu a que vos retorne els terminals corresponents.</p> <ul> <li> <p>Wireshark est\u00e0 instal\u00b7lat en el contenidor que fa de firewall, utilitzeu-lo per a vore el tr\u00e0fic que atravesa el firewall i per a depurar les vostres regles (interfaz <code>etho</code>)</p> <p><pre><code>wireshark &amp;\n</code></pre> + Tant en el client 1 com en el 2 per a explorar el serveis oferits pel PLC, podeu fer servir: <pre><code>./mbtcp-simple.py\n</code></pre> El que iniciar\u00e0 un client MODBUS senzill. Observa amb Wireshark el tr\u00e0fic que es genera, notant quin port TCP com a dest\u00ed utilitza el client quan es conecta amb el PLC.</p> </li> <li> <p>Inicia Firefox en cada client:     <pre><code>firefox &amp;\n</code></pre>   I accedeix a:</p> <pre><code>http://plc:8080\n\nhttp://plc:80\n</code></pre> </li> <li> <p>Per \u00faltim, accedeix per ssh des dels clients al PLC (no fa falta establir la conexi\u00f3, nom\u00e9s comprobar que n'hi ha acc\u00e9s):</p> <pre><code>ssh plc\n</code></pre> </li> </ul> <p>Tasca</p> <p>Fent \u00fas de Iptables instal\u00b7lat en el contenidor que fa de firewall, escriu unes regles per a que:</p> <ol> <li>El client 1 nom\u00e9s puga accedir al PLC per SSH i HTTP (port 8080 \u00fanicament)</li> <li>El client 2 nom\u00e9s tinga acc\u00e9s mitjan\u00e7ant MODBUS TCP i HTTP (ports 80 i 8080)</li> <li>No se permeteix cap altre t\u00e0fic dels clients al PLC</li> <li>Inclou una regla que puga logar totes les accions</li> </ol> <p>Tip</p> <p>Podeu agafar com a referencia el script d'exemple que teniu al firewall <code>example_fw.sh</code></p> <p>Fixeu-vos que en este script les IP poden ser diferents de les que vosaltres necessiteu. </p> <p>L'\u00faltima l\u00ednea del script loguea els missagte a: <code>/var/log/iptables.log</code>. Si incloeu esta directiva en la vostra configuraci\u00f3, podeu observar quan iptables fa drop dels paquets pertinents.</p> <p>Tasca</p> <p>Fent \u00fas del comando <code>tail -f /var/log/iptables.log</code>, mostra que es fa drop de paquets que no han d'estar permesos per Iptables.</p> <p>Mostra-lo igualment a Wireshark.</p>"},{"location":"idps/","title":"Monitorizaci\u00f3n mediante sistemas detectores de intrusos (IDS) y sistemas de prevenci\u00f3n de intrusos (IPS)","text":"<p>description:  Apuntes y pr\u00e1cticas Seguridad y Alta disponibilidad (SAD - ASIR). Dentro de la parte de seguridad defensiva del curso de especialista en ciberseguridad vamos a tratar esta vez los Intrusion Detection System (IDS), as\u00ed como los Intrusion Prevention System (IDP), enumerando sus ventajas y desventajas. En concreto vamos a trabajar con Suricata y justificaremos el motivo por el que lo preferiremos frente a Snort. </p>"},{"location":"idps/#introduccion","title":"Introducci\u00f3n","text":"<p>En esta secci\u00f3n vamos a hacer una revisi\u00f3n de los IDS, los IPS y, de refil\u00f3n, de los SIEM.  Se trata de tres herramientas que, aunque parecidas, contribuyen de forma diferente a la protecci\u00f3n de nuestras redes y sistemas. Estamos hablando de unas herramientas de monitorizaci\u00f3n puesto que examinan el tr\u00e1fico que entra y/o sale de nuestra red en b\u00fasqueda de comportamientos sospechosos.</p> <p></p>"},{"location":"idps/#ids","title":"IDS","text":"<p>Son sistemas que monitorizan el tr\u00e1fico entrante y lo cotejan con una base de datos actualizada de firmas de ataque conocidas. Ante cualquier actividad sospechosa, emiten una alerta a los administradores del sistema quienes han de tomar las medidas oportunas. Estos accesos pueden ser ataques espor\u00e1dicos realizados por usuarios malintencionados o repetidos cada cierto tiempo, lanzados con herramientas autom\u00e1ticas. Estos sistemas s\u00f3lo detectan los accesos sospechosos emitiendo alertas anticipatorias de posibles intrusiones, pero no tratan de mitigar la intrusi\u00f3n. Su actuaci\u00f3n es reactiva.</p>"},{"location":"idps/#como-funcionan-los-ids","title":"\u00bfC\u00f3mo funcionan los IDS?","text":"<p>Podemos distinguir dos tipos de IDS:</p> <ol> <li>NIDS (Network-based intrusion detections systems): Monitorizan el tr\u00e1fico de dos formas; o bien configur\u00e1ndolo para que todo el tr\u00e1fico de la red pase a trav\u00e9s de \u00e9l o haciendo un port mirroring.</li> <li>HIDS (Host-based intrusion detections systems): Se configura un sistema para comprobar actividad sospechosa o an\u00f3mala en un host concreto en lugar de en toda la red. Esto limita en gran medida los dipositivos que se monitorizan pero permite detectar con mayor detalle amenazas en ese host.</li> </ol> <p>T\u00edpicamente se utilizan tres metodolog\u00edas para detectar incidentes:</p> <ul> <li> <p>Basada en firmas: compara las firmas con los eventos observados para identificar posibles incidentes. Se trata del m\u00e9todo de detecci\u00f3n m\u00e1s sencillo, ya que compara \u00fanicamente la unidad de actividad actual (como por ejemplo un paquete o una entrada de log) contra una lista de firmas mediante operaciones de comparaci\u00f3n de cadenas.      Estas firmas permiten al IDS distinguir entre el uso normal del PC y el uso fraudulento, y/o entre el tr\u00e1fico normal de la red y el tr\u00e1fico que puede ser resultado de un ataque o intento del mismo y sonpatrones de ataque preconfigurados y predeterminados.</p> <p></p> </li> <li> <p>Detecci\u00f3n basada en anomal\u00edas: compara las definiciones de lo que se considera una actividad normal con los eventos observados para identificar desviaciones significativas. Este m\u00e9todo de detecci\u00f3n puede ser muy eficaz para detectar amenazas desconocidas hasta ahora.</p> <p></p> </li> <li> <p>An\u00e1lisis de protocolos de estado: utiliza informaci\u00f3n sobre las conexiones entre hosts y la compara con las entradas de una tabla de estado. La tabla de estado mantiene un registro de la conexi\u00f3n entre las computadoras que incluye: direcci\u00f3n IP de origen y puerto, direcci\u00f3n IP de destino y puerto, y los protocolos que se utilizan.      Este m\u00e9todo busca cambios repentinos o bruscos en la actividad de la red. Otras funciones incluyen a veces el seguimiento del estado del protocolo, los an\u00e1lisis din\u00e1micos del protocolo de aplicaci\u00f3n y el reensamblaje de paquetes IP, lo que evita que fragmentos de paquetes IP lleguen a la red interna.</p> <p>Entre las ventajas del an\u00e1lisis de protocolo de estado est\u00e1n:</p> <ul> <li>Identifica secuencias inesperadas de comandos.</li> <li>A\u00f1ade caracter\u00edsticas de estado al an\u00e1lisis regular de protocolos.</li> <li>Comprueba la racionalidad de los umbrales de los comandos individuales.</li> </ul> <p>Entre las desventajas est\u00e1n:</p> <ul> <li>Uso intensivo de recursos, sobrecarga de recursos elevada.</li> <li>No puede detectar ataques que no violen las caracter\u00edsticas de comportamiento del protocolo generalmente aceptado.</li> <li>Presenta conflictos entre el modelo de protocolo utilizado por el sistema y c\u00f3mo se implementa realmente el protocolo.</li> </ul> </li> </ul>"},{"location":"idps/#ips","title":"IPS","text":"<p>IPS (Intrusion Prevention System) o sistema de prevenci\u00f3n de intrusiones: es un software que se utiliza para proteger a los sistemas de ataques e intrusiones. Como su nombre indica, su actuaci\u00f3n es de car\u00e1cter preventivo. </p> <p>Estos sistemas llevan a cabo un an\u00e1lisis en tiempo real de las conexiones y los protocolos para determinar si se est\u00e1 produciendo o se va a producir un incidente, identificando ataques seg\u00fan patrones, anomal\u00edas o comportamientos sospechosos y permitiendo el control de acceso a la red, implementando pol\u00edticas que se basan en el contenido del tr\u00e1fico monitorizado, es decir, el IPS adem\u00e1s de lanzar alarmas, puede descartar paquetes y desconectar conexiones.</p> <p></p> <p>Muchos proveedores ofrecen productos mixtos, llam\u00e1ndolos IPS/IDS, integr\u00e1ndose frecuentemente con cortafuegos y UTM (en ingl\u00e9s Unified Threat Management o Gesti\u00f3n Unificada de Amenazas) que controlan el acceso en funci\u00f3n de reglas sobre protocolos y sobre el destino u origen del tr\u00e1fico.</p> <p></p>"},{"location":"idps/#limitaciones-de-de-los-idsips","title":"Limitaciones de de los IDS/IPS","text":"<p>No todo es bonito con estos sistemas, algunos de sus handicaps m\u00e1s importantes son:</p> <ul> <li>Un IDS s\u00f3lo detectar\u00e1 lo que est\u00e9 configurado para detectar. Es decir, est\u00e1n limitados \u00fanicamente a detectar ataques ya conocidos. </li> <li>Son completamente dependientes de las reglas que escribamos o les carguemos y esto lleva inevitablemente a los falsos positivos. Una regla configurada para detectar un ataque tambi\u00e9n puede generar una alerta ante tr\u00e1fico leg\u00edtimo si \u00e9sta no ha sido configurada con sumo cuidado o si el ataque usa un patr\u00f3n com\u00fan de tr\u00e1fico.</li> <li>Capacidades limitadas ante tr\u00e1fico cifrado.</li> <li>Su visibilidad est\u00e1 limitada en funci\u00f3n de d\u00f3nde se coloquen en la red.</li> </ul>"},{"location":"idps/#siem","title":"SIEM","text":"<p>SIEM (Security Information and Event Management) o sistema de gesti\u00f3n de eventos e informaci\u00f3n de seguridad: es una soluci\u00f3n h\u00edbrida centralizada que engloba la gesti\u00f3n de informaci\u00f3n de seguridad (Security Information Management) y la gesti\u00f3n de eventos (Security Event Manager). </p> <p>La tecnolog\u00eda SIEM proporciona un an\u00e1lisis en tiempo real de las alertas de seguridad generadas por los distintos dispositivos hardware y software de la red. Recoge los registros de actividad (logs) de los distintos sistemas, los relaciona y detecta eventos de seguridad, es decir, actividades sospechosas o inesperadas que pueden suponer el inicio de un incidente, descartando los resultados an\u00f3malos, tambi\u00e9n conocidos como falsos positivos y generando respuestas acordes en base a los informes y evaluaciones que registra, es decir, es una herramienta en la que se centraliza la informaci\u00f3n y se integra con otras herramientas de detecci\u00f3n de amenazas.</p> <p></p>"},{"location":"idps/#suricata","title":"Suricata","text":"<p>Suricata es un sistema de detecci\u00f3n de c\u00f3digo abierto que puede actuar tanto como IDS como IPS. Su desarrollo corresponde a Open Information Security Foundation (OSIF). Utiliza un set de reglas y firmas que permite detectar y prevenir amenazas. Puede correr en Windows, Mac, Unix y Linux.</p> <p></p>"},{"location":"idps/#suricata-vs-snort","title":"Suricata vs Snort","text":"<p>Snort es el otro gran actor conocido en el juego de los IDS. Tambi\u00e9n de c\u00f3digo abierto, aunque posee dos sets de reglas principales: las community edition y las de suscriptor. Estas \u00faltimas son de pago y est\u00e1n desarrolladas, probadas y aprobadas por el grupo de seguridad de Cisco, Talos. </p> <p></p> <p>En esencia, Suricata permite acciones por defecto (principalmente relacionadas con la funcionalidad de IPS), que Snort no. No obstante, con una serie de modificaciones es posible hacer que la funcionalidad de Snort pueda ser casi igual, sino igual, a la de Suricata. A\u00fan con todo esto y siempre sin tener en cuenta preferencias personales, podemos destacar algunas ventajas de Suricata:</p> <ul> <li>Trabaja con multithreading. Esto representa una gran ventaja puesto que a d\u00eda de hoy es normal analizar grandes cantidades de tr\u00e1fico que requieren un gran procesado, por lo que sin duda este punto marca una gran diferencia.</li> <li>Es multitenancy. Esto quiere decir que podemos tener diferentes conjuntos de reglas aplic\u00e1ndose al mismo tiempo y asignar cada una de ellas a una VLAN diferente, por ejemplo.</li> <li>Se podr\u00eda decir que el logging de Suricata es de mejor calidad y que permite extraer mayor informaci\u00f3n del tr\u00e1fico que lo atraviesa.</li> <li>Permite utilizar directamente, sin modificaci\u00f3n alguna, las reglas de Snort.</li> </ul> <p>Como todo, siempre hay desventajas o inconvenientes, quiz\u00e1s incluso aplicable a cualquier IDS/IPS:</p> <ul> <li>La configuraci\u00f3n es ardua y dif\u00edcil. Tunearlo hasta que sea realmente \u00fatil puede llegar a ser un aut\u00e9ntico calvario que haga replantearse la utilidad vs esfuerzo.</li> <li>Una de las causas del punto anterior ser\u00eda la gran cantidad de falsos positivos debido a reglas, en ocasiones, demasiado gen\u00e9ricas. Las reglas de pago de Snort por ejemplo mejoran esto en gran medida.</li> <li>Las empresas que se lo pueden permitir econ\u00f3micamente suelen desestimar Suricata en favor de soluciones comerciales como los NGFW (Next Generation Firewalls) o plataformas como las de Fortinet o IBM.</li> <li>Hoy en d\u00eda gran cantidad del tr\u00e1fico va cifrado y el SSL Stripping puede convertirse en un gran problema, ya sea por condiciones de confidencialidad, como por la gran cantidad de recursos que supone de hardware, de adminstraci\u00f3n de endpoints o errores de certificados en los firewalls.</li> </ul>"},{"location":"idps/#demo-y-ejercicios","title":"Demo y ejercicios","text":"<p>Info</p> <p>Para este ejercicio he utilizado una m\u00e1quina virtual Debian 11 Bullseye con la interfaz en modo puente, instalando Suricata desde los repositorios. Si bien Suricata puede instalarse en cualquier distribuci\u00f3n, es posible que necesit\u00e9is algunos pasos adicionales o algo diferentes si utiliz\u00e1is otra.</p> <p>Atenci\u00f3n</p> <p>Todos los comandos de esta demo han sido ejecutados con el usuario root o, en su defecto, usando <code>sudo</code>.</p> <p>En este ejercicio deber\u00e9is llevar a cabo las siguientes acciones:</p> <ol> <li> <p>Instalar Suricata     Hay varias opciones para instalar:</p> <ul> <li>Desde el repositorio de paquetes de la distribuci\u00f3n Linux en concreto</li> <li>Desde un repositorio personal (PPA)</li> <li>Compilando el c\u00f3digo fuente</li> </ul> <p>Yo os recomiendo la primera opci\u00f3n, que siempre es la m\u00e1s sencilla.</p> </li> <li> <p>Configurarlo como IDS</p> <ul> <li>El archivo de configuraci\u00f3n a modificar est\u00e1 en <code>/etc/suricata/suricata.yaml</code></li> <li> <p>Comprobad el nombre de la interfaz de vuestra m\u00e1quina:</p> <p></p> </li> <li> <p>Tras ello, en el archivo de configuraci\u00f3n anterior, colocadlo donde corresponde en la secci\u00f3n <code>af.packet</code> del mismo:   </p> <p></p> </li> <li> <p>Para permitir que Suricata permita una recarga en vivo de las reglas, es decir, que se puedan a\u00f1adir, eliminar y editar las reglas sin la necesidad de reiniciar el proceso de Suricata:    </p> <p></p> <p>Y con este comando le diremos a Suricata que recargue todas las reglas sin reiniciar el proceso:</p> <pre><code>kill -usr2 $(pidof suricata)\n</code></pre> </li> <li> <p>Actualizamos las reglas de Suricata:</p> <pre><code>suricata-update -o /etc/suricata/rules\n</code></pre> </li> <li> <p>Y para validar la configuraci\u00f3n (tardar\u00e1 un poco):     </p> </li> <li> <p>Se inicia el servicio y se comprueba que est\u00e1 activo (tardar\u00e1 un par de minutos en cargar y parsear las reglas):     <pre><code>systemctl start suricata.service\nsystemctl start suricata.service\n</code></pre> </p> </li> </ul> </li> <li> <p>Comprobar que muestra las alertas que detecta de acuerdo a sus reglas</p> <ul> <li> <p>Probaremos la siguiente regla (explicaci\u00f3n del formato de las reglas/firmas):</p> <p></p> <p>Que generar\u00e1 una alarma cuando un posible intruso use el comando <code>id</code> y \u00e9ste responda con root. </p> <p>Para comprobarlo, accederemos a un site que simule este comportamiento ejecutando lo el siguiente comando:</p> <pre><code>curl http://testmynids.org/uid/index.html\n</code></pre> </li> <li> <p>Y examinamos los logs en busca de la alerta, utilizando su identificador:</p> <p></p> <p>Suricata tambi\u00e9n loguea eventos en <code>/var/log/suricata/eve.log</code> usando un formato JSON. La documentaci\u00f3n de Suricata recomienda usar la utilidad <code>jq</code> para leer y filtrar las entradas de este archivo. As\u00ed pues, lo instalamos:</p> <pre><code>apt install jq\n</code></pre> <p>Y buscamos la alerta correspondiente:</p> <pre><code>jq 'select(.alert .signature_id==2100498)' /var/log/suricata/eve.json\n</code></pre> </li> </ul> <p>Tarea</p> <p>Documenta adecuadamente todo este proceso con las capturas de pantalla y las explicaciones pertinentes que demuestren la realizaci\u00f3n y comprobaci\u00f3n del mismo.</p> </li> <li> <p>Configurar Suricata como IPS y comprobar su funcionamiento</p> <p>En este caso vamos a ver como trabajar en capa 3 con el modo inline de Suricata usando <code>iptables</code>. Para ello, necesitamos instalar una dependencia:</p> <pre><code>apt-get -y install libnetfilter-queue-dev\n</code></pre> <p>Ahora haremos que Suricata corra en modo NFQ, o lo que es lo mismo, le decimos que acepte los paquetes que le reenv\u00ede <code>iptables</code> sin que el firewall siga aplicando sus reglas al paquete (es posible que tarde varios minutos):</p> <p><pre><code>suricata -c /etc/suricata/suricata.yaml -q 0\n</code></pre> De la misma forma, debemos decirle al firewall que reenv\u00ede todos los paquete que entran y salen de nuestra m\u00e1quina a Suricata:</p> <pre><code>sudo iptables -I INPUT -j NFQUEUE\nsudo iptables -I OUTPUT -j NFQUEUE\n</code></pre> <p>Podemos ver las reglas activas del firewall con:</p> <pre><code>iptables -vnL\n</code></pre> <p>Por defecto Suricata corre en modo IDS as\u00ed que para activar el IPS haremos:</p> <p><pre><code>systemctl edit suricata.service\n</code></pre> Y a\u00f1adimos las l\u00edneas resaltadas:</p> <pre><code>### Editing /etc/systemd/system/suricata.service.d/override.conf\n### Anything between here and the comment below will become the new contents of the file\n[Service]\nExecStart= \nExecStart=/usr/bin/suricata -c /etc/suricata/suricata.yaml --pidfile /run/suricata.pid -q 0 -vvv\nType=simple\n### Lines below this comment will be discarded\n. . .\n</code></pre> <p>Donde <code>ExecStart=</code> borra el comando por defecto que systemd utiliza para iniciar un servicio. La siguiente l\u00ednea define el nuevo comando a utilizar y <code>Type=simple</code> se asegura de que systemd pueda manejar el proceso de Suricata como cualquier otro servicio cuando est\u00e1 corriendo en modo IPS.</p> <p>Guardamos y reiniciamos systemd para que detecte la nueva configuraci\u00f3n del servicio de Suricata:</p> <pre><code>systemctl daemon-reload\n</code></pre> <p>Reiniciamos Suricata y comprobamos su estado:</p> <pre><code>sudo systemctl restart suricata.service\nsudo systemctl status suricata.service\n</code></pre> <p>Tarea</p> <p>Modifica la regla que hemos comprobado anteriormente para que en lugar de generar una alerta (alert), descarte (drop) los paquetes que hagan match con esa regla.</p> </li> <li> <p>Escribir una regla para el IPS y comprobar que funciona</p> <p>Para este cometido vamos otra vez al archivo de configuraci\u00f3n <code>suricata.yaml</code> y le vamos a indicar que tenga en cuenta un nuevo fichero de reglas/firmas que crearemos m\u00e1s tarde con nuestra regla concreta:</p> <p></p> <p>Tarea</p> <p>A partir de la documentaci\u00f3n proporcionada o de otra que pod\u00e1is encontrar por Internet, escribid una regla de Suricata para que cuando se produzca una conexi\u00f3n desde cualquier IP origen a cualquier IP destino y puerto 8000, el tr\u00e1fico sea bloqueado por <code>iptables</code>.  Ponedle SID 9000001 por ejemplo, para que no haya conflicto con otra regla ya existente. Para comprobarla, en la m\u00e1quina donde est\u00e1 Suricata:</p> <pre><code>nc -nvlp 8000\n</code></pre> <p>Y en la m\u00e1quina anfitriona:</p> <p><pre><code>nc IP_Maq_Virtual 8000\n</code></pre> </p> <p>Nota</p> <p>Recordad el comando para recargar las reglas (puede tardar un rato): <pre><code>kill -USR2 $(pidof suricata)\n</code></pre> Si no os funciona, de acuerdo con la documentaci\u00f3n, probad:</p> <pre><code>suricatasc -c ruleset-reload-nonblocking\n</code></pre> </li> </ol>"},{"location":"idps/#per-a-rocky-linux","title":"Per a Rocky Linux","text":""},{"location":"idps/#ids_1","title":"IDS","text":"<p>Molts m'heu fet saber que no vos ha funcionat la pr\u00e0ctica amb Ubuntu tampoc. En aquest cas, aprofitarem la m\u00e0quina virtual de Rocky Linux, on jo mateix he comprovat que funciona correctament.</p> <p>En primer lloc, per a la instal\u00b7laci\u00f3 i posterior configuraci\u00f3 de Rocky Linux com a IDS, podem seguir el seg\u00fcent tutorial i no les instruccions anteriors, que eren nom\u00e9s per a Debian:</p> <p>How To Install Suricata on Rocky Linux 8</p> <p>On s'explica perfectament com instalar i configurar Suricata, aix\u00ed com la manera de fer la mateixa comprovaci\u00f3 de la regla de Suricata.</p> <p>Si teniu qualsevol problema, comproveu que:</p> <ul> <li>El firewall est\u00e0 desactivat, sin\u00f2 desactiveu-lo: <code>systemctl status firewalld</code></li> <li>Que a l'arxiu de configuraci\u00f3 <code>/etc/suricata/suricata.yml</code> heu canviat en tots els llocs on apareix el nom de la interfaz, per el nom de la vostra</li> <li>Que a l'arxiu <code>/etc/sysconfig/suricata</code> no apareix cap nom d'interfaz que no siga el vostre</li> </ul> <p>Una vegada feta esta part, pasarem a la seg\u00fcent, configurar Suricata com a IPS.</p>"},{"location":"idps/#ips_1","title":"IPS","text":"<p>En aquest cas, ja sabeu que a m\u00e9s d'inspeccionar el tr\u00e0fic, haurem de tallar-lo en cas de trobar activitat sospitosa. </p> <p>Question</p> <p>\u00bfQui pot tallar el tr\u00e0fic de la xarxa? </p> <p>Efectivament, el firewall. Suricata haur\u00e0 de treballar amb el firewall per a fer d'IPS.</p> <p>Podeu seguir qualsevol tutorial, sempre sent conscients de qu\u00e8 esteu fent per favor. Jo vos recomane este: How To Configure Suricata as an Intrusion Prevention System (IPS) on Rocky Linux 8</p> <p>Si llegiu amb atenci\u00f3 el tutorial, \u00e9s en el pas 3 concretament a \u00f3n comen\u00e7a a configurar-se Suricata per a intercontectar-se amb el firewall, aix\u00ed doncs, podeu obviar el passos anteriors.</p> <p>Despr\u00e9s, seguint amb el passos del tutorial, podeu comprobar amb la regla de l'apartat anterior, si canviant el <code>alert</code> per un <code>drop</code> es talla el tr\u00e0fic (haur\u00e0 de donar timeout i haura de vore-se en els logs).</p> <p>Una vegada comprovat que l'IPS funciona, haureu d'escriure ara s\u00ed, una regla pr\u00f2pia a l'arxiu <code>local.rules</code>, tal i com s'explicava en el punt 5 de la pr\u00e1ctica de Debian:</p> <p></p>"},{"location":"idps/#referencias","title":"Referencias","text":"<p>\u00bfQu\u00e9 son y para qu\u00e9 sirven los SIEM, IDS e IPS?</p> <p>Suricata vs snort </p> <p>How to install Suricata in Debian 11</p> <p>How To Install Suricata on Debian 11/Debian 10</p> <p>Suricta User Guide</p>"},{"location":"iptables/","title":"Administraci\u00f3 senzilla de regles d'iptables fent servir Docker","text":""},{"location":"iptables/#introduccio","title":"Introducci\u00f3","text":"<p>Per a simplificar la infraestructra necess\u00e0ria per a esta pr\u00e0ctica, farem servir un framework anomenat Labtainer. Este framework es capa\u00e7 de crear diferents laboratoris o escenaris basats en contenidors de Docker. </p> <p>En concret, el nostre escenari ser\u00e0 tal que aix\u00ed:</p> <p></p>"},{"location":"iptables/#labtainer","title":"Labtainer","text":"<p>Descarregueu la imatge <code>.ova</code> del link que teniu a Aules i importeu-la en Virtualbox.</p> <p>Per tal d'iniciar el laboratori, no tanqueu el terminal s'obrir\u00e0 autom\u00e0ticament i introudiu:</p> <pre><code>labtainer iptables2\n</code></pre> <p>I comen\u00e7aran a desplegar-se els contenidors i se vos obrir\u00e0n dues pestanyes en el terminal del firewall. </p> <p>Nota</p> <p>Quan vos pregunte per l'email, deixeu-lo en blanc i dieu-li que esteu segurs de deixar-lo en blanc <code>(y)</code></p> <p>Per a accedir al terminal de qualsevol contenidor podeu fer servir:</p> <pre><code>docker exec -it &lt;nom_del_contenidor&gt; /bin/bash\n</code></pre>"},{"location":"iptables/#tasques","title":"Tasques","text":"<p>Des del client prova a fer un escaneig de ports al server i comenta el resultats:</p> <pre><code>nmap server\n</code></pre> <p>Prova a accedir per SSH:</p> <pre><code>ssh server\n</code></pre> <p>I confirma que s'oferix el servici de Telnet:</p> <pre><code>telnet server\n</code></pre> <p>Al contenidor firewall est\u00e0 instal\u00b7lat Iptables. Fes-lo servir per a permetre \u00fanicament la redirecci\u00f3 (forwarding) de tr\u00e0fic SSH i HTTP. Per tal d'ajudar-te, pots experimentar amb el script <code>example fw.sh</code>.</p> <p>Atenci\u00f3</p> <p>Considera posar les teues regles d'iptables en un script per tal de poder aplicar-les r\u00e0pidament sempre que ho necessites. </p> <p>Comprova els packets descartats (drop) mirant el logs i assenyalant clarament dins del log on es produeix el drop:</p> <pre><code>tail -f /var/log/iptables.log\n</code></pre> <p>El contenidor firewall tamb\u00e9 t\u00e9 instal\u00b7lada l'aplicaci\u00f3 wireshark, fes-la servir per a vore els drops tamb\u00e9:</p> <pre><code>wireshark &amp;\n</code></pre> <p>Una vegada has limitat el tr\u00e0fic amb iptables, torna a fer el escaneig de ports per a comprovar que la nova situaci\u00f3 \u00e9s correcta.</p>"},{"location":"iptables/#obrir-un-port-per-a-un-nou-servici","title":"Obrir un port per a un nou servici","text":"<p>El contenidor del client inclou un programa anomenat wizbang. Executa este script i comprova quin \u00e9s el port que est\u00e0 intentant utilitzar per a enviar el tr\u00e0fic. </p> <p>Una vegada comprovat, introdueix una regla que permeta este tr\u00e0fic i comprova que funciona correctament (de les dues formes comentades a clase). </p> <p>Fes tamb\u00e9 la comprovaci\u00f3 amb un nou escaneig de ports.</p> <p>Una vegada heu acabat, pareu el laboratori al terminal original amb:</p> <pre><code>stoplab\n</code></pre>"},{"location":"proxy-caddy/","title":"Configuraci\u00f3n de Caddy como proxy inverso para contenedores Docker","text":""},{"location":"proxy-caddy/#que-es-caddy","title":"\u00bfQu\u00e9 es Caddy?","text":"<p>Caddy 2 es un potente servidor web de c\u00f3digo abierto desarrollado haciendo uso del lenguaje de programaci\u00f3n Go.</p> <p>Simplifica la infraestructura a montar y se encarga de forma autom\u00e1tica de las renovaciones de certificados SSL para los sitios web. Aunque comunmente se usa como servidor web o proxy, tambi\u00e9n se podr\u00eda utilizar para otras funciones:</p> <ul> <li>Proxy sidecar</li> <li>Balanceador de carga</li> <li>Puerta de enlace API</li> <li>Control de ingreso </li> </ul> <p></p> <p>Es una aplicaci\u00f3n con un enfoque m\u00e1s cl\u00e1sico que Traefik y s\u00ed tiene ficheros de configuraci\u00f3n. Pero al mismo tiempo est\u00e1 pensado para ser muy simple, y gestionar autom\u00e1ticamente y por defecto cosas que en otro servidores web habr\u00eda que hacer de forma expl\u00edcita.</p>"},{"location":"proxy-caddy/#como-funciona-caddy","title":"\u00bfC\u00f3mo funciona Caddy?","text":"<p>Un proxy inverso es un intermediario entre los dispositivos cliente y los servidores web, administrando las peticiones y respuestas con el fin de mejorar la seguridad, el rendimiento y la flexibilidad.</p> <p> </p> <p>Caddy permite:</p> <ul> <li> <p>Configuraci\u00f3n SSL/TLS autom\u00e1tica: Caddy se integra sin problemas con Let's Encrypt de tal forma que es capaz de obtener y renovar de forma autom\u00e1tica los certificados SSL/TLS para HTTPS, asegurando siempre una comunicaci\u00f3n segura.     Tambi\u00e9n incluye y configura autom\u00e1ticamente unos certificados autofirmados para entornos locales o de desarrollo.</p> </li> <li> <p>Configuraci\u00f3n mediante un archivo llamado Caddyfile, haci\u00e9ndolo muy simple.</p> </li> <li>Soporte para los nuevos protocolos HTTP/2 y QUIC </li> <li>Monitorizaci\u00f3n y m\u00e9tricas en tiempo real, compatibles con sistemas de monitorizaci\u00f3n como Prometheus.</li> <li>Middleware y extensiones: Caddy permite, haciendo uso de plugins, a\u00f1adir funcionalidades interesantes a la aplicaci\u00f3n</li> </ul>"},{"location":"proxy-caddy/#objetivo-de-la-practica","title":"Objetivo de la pr\u00e1ctica","text":"<p>El objetivo de esta pr\u00e1ctica ser\u00e1 configurar un contenedor Docker de Caddy como proxy inverso para apliciaciones web, tambi\u00e9n desplegadas en contenedores Docker. Adem\u00e1s, Caddy utilizar\u00e1 certificados autofirmados para que el acceso a las aplicaciones web se efect\u00fae de forma segura mediante HTTPS.</p>"},{"location":"proxy-caddy/#realizacion","title":"Realizaci\u00f3n","text":"<p>Dado el siguiente archivo donde se despliegan los elementos necesarios:</p> compose.yaml<pre><code>#-----------------------------------------------------------------------------------------------\n# ! Este archivo docker compose es apto para entornos locales o de desarrollo, no de producci\u00f3n. \n#-----------------------------------------------------------------------------------------------\n# Nombre del proyecto\nname: docker-reverse-proxy\n# Servicios Docker.\nservices:\n# Contenedor de Caddy\ncaddy:\n# https://hub.docker.com/_/caddy\nimage: caddy:alpine\ncontainer_name: ${CONTAINER_NAME:-reverse_proxy}\nrestart: unless-stopped\nnetworks:\n- reverse_proxy\n# Mapea los puertos expuestos en las aplicaciones a los puertos del host o m\u00e1quina anfitri\u00f3n\nports:\n- 80:80\n- 443:443\n- ${ADMIN_API_PORT:-2019}:2019\nvolumes:\n- caddy_data:/data\n- caddy_config:/config\n# Archivo de configuraci\u00f3n de Caddy\n- $PWD/config/Caddyfile:/etc/caddy/Caddyfile\n# Autoridad de certificaci\u00f3n (CA) de Caddy\n- $PWD/certificate-authority:/data/caddy/pki/authorities/local\n# Aplicaci\u00f3n web de prueba con nginx\nwebsite:\nimage: \"nginxdemos/hello\"\ncontainer_name: app_demo\n# Correspondencia entre puerto utilizado por el contenedor y el accesible desde el anfitri\u00f3n\nports:\n- 8080:80\nnetworks:\n- reverse_proxy\n# Redes de Docker\nnetworks:\nreverse_proxy:\nexternal: true\n# Vol\u00famenes de Docker\nvolumes:\ncaddy_data:\ndriver: \"local\"\nname: \"${CONTAINER_VOLUME_DATA_NAME:-reverse_proxy_data}\"\ncaddy_config:\ndriver: \"local\"\nname: \"${CONTAINER_VOLUME_CONFIG_NAME:-reverse_proxy_config}\"\n</code></pre> <p>Se requiere modificar el archivo de configuraci\u00f3n Caddyfile:</p> <pre><code>#--------------------------------------------------------------------------\n# Caddy configuration\n# https://caddyserver.com/docs/caddyfile/options\n#--------------------------------------------------------------------------\n\n{\n  debug\n  local_certs\n  auto_https disable_redirects\n  admin 0.0.0.0:2019\n}\n\n#--------------------------------------------------------------------------\n# Reverse proxy\n# https://caddyserver.com/docs/caddyfile/directives/reverse_proxy\n#--------------------------------------------------------------------------\n\n# Aqu\u00ed se configura el acceso HTTP al contenedor de la aplicaci\u00f3n web\n# Tambi\u00e9n se debe configurar para que el acceso http sea redirigido autom\u00e1ticamente al bloque de https\n\n# Bloque HTTP\n\n________:____ {\n  redir ___________\n}\n\n# Bloque HTTPS\n\n________:_____ {\n  tls internal\n  reverse_proxy _____\n\n}\n</code></pre> <p>Para que:</p> <ul> <li>En el primer bloque, se tenga acceso HTTP a la aplicaci\u00f3n<ul> <li>Pero se haga una redirecci\u00f3n al bloque de HTTPS</li> </ul> </li> <li>En el segundo bloque est\u00e9 configurado el acceso HTTPS<ul> <li>Realizando las labores de proxy inverso, se redirija la petici\u00f3n a la aplicaci\u00f3n en cuesti\u00f3n</li> </ul> </li> </ul> <p>Atenci\u00f3n</p> <p>Caddy tiene utiliza un DNS interno que es capaz de resolver los nombres de los contenedores, por lo que, aunque se podr\u00eda, no hace falta utilizar IPs para nada en la configuraci\u00f3n.</p> <p>Tarea</p> <ul> <li>Investiga el funcioamiento de este archivo de configuraci\u00f3n y compl\u00e9talo tal y como se solicita par hacerlo funcionar</li> <li>Comprueba con tu navegador que funciona correctamente:<ul> <li>Al acceder por http se te redirige a https</li> <li>La primera vez que accedas dar\u00e1 una alerta de seguridad al ser un certificado autofirmado, dadle a aceptar el riesgo </li> </ul> </li> </ul>"},{"location":"proxy-caddy/#redireccion-automatica-de-http-a-https","title":"Redirecci\u00f3n autom\u00e1tica de HTTP a HTTPS","text":"<p>De alguna forma, en el apartado anterior hemos realizado esta redirecci\u00f3n a una comunicaci\u00f3n segura de forma manual. No obstante, la sencillez de Caddy hace que el mismo proxy realice esta redirecci\u00f3n de forma autom\u00e1tica, si nuestra intervenci\u00f3n, a menos que nosotros le digamos lo contrario.</p> <p>Tarea</p> <ul> <li>Elimina el bloque completo de HTTP del archivo Caddyfile, dejando \u00fanicamente el de HTTPS</li> <li>Investiga que opci\u00f3n de configuraci\u00f3n del archivo Caddyfile debemos eliminar para que se realice la redirecci\u00f3n autom\u00e1ticamente</li> <li>Comprueba que funciona correctamente</li> </ul> <p>Tarea</p> <ul> <li>En el <code>compose.yaml</code> a\u00f1ade una nueva aplicaci\u00f3n, como por ejemplo esta y config\u00farala de la misma forma que la anterior.</li> </ul>"},{"location":"proxy-caddy/#para-nota","title":"Para nota","text":"<p>Caddy puede funcionar tambi\u00e9n de la misma forma que lo hace Traefik, usando etiquetas (labels) en el <code>compose.yml</code>. Para ello utiliza un plugin que se denomina <code>caddy-docker-proxy</code>.</p> <p>Tarea</p> <p>Investiga esta opci\u00f3n y realiza de nuevo la pr\u00e1ctica anterior mediante labels en lugar de utilizar el archivo de configuraci\u00f3n Caddyfile</p>"},{"location":"proxy-caddy/#referencias","title":"Referencias","text":"<p>Proxy Inverso con Caddy</p> <p>De Apache a Caddy</p> <p>Create and build simple reverse proxy with Caddy1</p> <p>Caddy como proxy inverso pero muy f\u00e1cil</p>"},{"location":"proxy-traefik/","title":"Configuraci\u00f3n de Traefik como proxy inverso para contenedores Docker","text":""},{"location":"proxy-traefik/#que-es-traefik","title":"\u00bfQu\u00e9 es Traefik?","text":"<p>Respuesta r\u00e1pida: Traefik es un proxy inverso y balanceador de carga que se integra nativamente con Docker.</p> <p>De forma un poco m\u00e1s completa, Traefik act\u00faa como router, interceptando y enrutando todas las solicitudes entrantes a los servicios del backend qu\u00e9 corresponda en cada caso. Esto es especialmente en entornos muy grandes con gran n\u00famero de servicios o microservicios.</p> <p>Una potente funcionalidad de Traefik es el hecho de realizar un descubrimiento din\u00e1mico de los servicios que debe enrutar. Si a\u00f1adimos un nuevo servicio, s\u00f3lo debemos a\u00f1adir el endpoint adecuado para que Traefik se encargue de todo lo dem\u00e1s y lo deje funcionando correctamente.</p> <p></p> <p>Aunque existen otras alternativas bastate potentes, \u00fatiles y conocidas, en este caso trataremos con una de las m\u00e1s populares para tener un ligero conocimiento de la misma.</p>"},{"location":"proxy-traefik/#como-funciona-traefik","title":"\u00bfC\u00f3mo funciona Traefik?","text":"<p>En esta imagen vemos meridianamente claro el funcionamiento de este edge router o router de frontera1, como es Traefik.</p> <p>De acuerdo con la documentaci\u00f3n oficial de Traefik:</p> <ul> <li> <p>Puntos de entrada: Los EntryPoints son los puntos de entrada de la red a Traefik. Definen el puerto que recibir\u00e1 los paquetes y si escuchar\u00e1 TCP o UDP.</p> </li> <li> <p>Enrutadores: Un router se encarga de conectar las peticiones entrantes con los servicios que pueden gestionarlas.</p> </li> <li> <p>Middlewares: Adjuntos a los routers, los middlewares pueden modificar las peticiones o respuestas antes de que sean enviadas a su servicio</p> </li> <li> <p>Servicios: Los servicios se encargan de configurar c\u00f3mo llegar a los servicios reales que finalmente gestionar\u00e1n las peticiones entrantes.</p> </li> </ul>"},{"location":"proxy-traefik/#objetivo-de-la-practica","title":"Objetivo de la pr\u00e1ctica","text":"<p>En esta pr\u00e1ctica tendremos dos servicios, uno al que se acceder\u00e1 mediante la url <code>http://localhost</code>y otro mediante la url <code>http://localhost/whoami2</code>. Ser\u00e1 Traefik el encargado de decidir hacia qu\u00e9 servicio o contenedor dirigir\u00e1 la petici\u00f3n en base a esta url 2.</p> <p></p> <p>Adem\u00e1s, cada uno de los dos servicios estar\u00e1n formados por m\u00e1s de una instancia o contenedor, por lo que el proxy inverso adem\u00e1s de enrutar tambi\u00e9n realizar\u00e1 un balanceo de carga.</p> <p>Una vez tengamos funcionando el escenario, utilizaremos otras funcionalidades del proxy.</p>"},{"location":"proxy-traefik/#realizacion","title":"Realizaci\u00f3n","text":""},{"location":"proxy-traefik/#configuracion-de-traefik","title":"Configuraci\u00f3n de Traefik","text":"<p>Vamos a utilizar el siguiente archivo:</p> docker-compose.yml<pre><code>networks:\nred_traefik:\ndriver: bridge\nipam:\nconfig:\n- subnet: 172.24.0.0/24 #(5)\nservices:\ntraefik:\nimage: \"traefik:v2.6\"\ncommand:\n#- \"--log.level=DEBUG\"\n- \"--api.insecure=__________\" #(1)\n- \"--providers.docker=______\" #(2)\n- \"--providers.docker.exposedbydefault=_______\" #(3)\n- --providers.file.directory=/certificados\n- --providers.file.watch=true\n- \"--entrypoints.____.address=____\" #(4)\nports:\n- \"80:80\"\n- \"8080:8080\"\nvolumes:\n- \"/var/run/docker.sock:/var/run/docker.sock:ro\"\n- \"./certificados:/certificados\"\nnetworks:\n- red_traefik\n</code></pre> <ol> <li>Permite el acceso al panel de control web de Traefik. S\u00f3lo para escenarios de pruebas, debe deshabilitarse en producci\u00f3n.</li> <li>Habilita el descubrimiento autom\u00e1tico de configuraciones Docker</li> <li>No exponer los servicios de Docker por defecto</li> <li>Crea un entrypoint llamado web y que escucha en el puerto 80</li> <li>Direcci\u00f3n de subred en la que ubicaremos a nuestros contenedores/servicios</li> </ol> <p>En la secci\u00f3n ports exponemos el puerto 80 para permitirel acceso al entrypoint web y el puerto 8080 es el puerto por defecto del panel de control web de Traefik.</p> <p>Adem\u00e1s, se necesita crear un volumen y conectarlo con docker.sock para que Traefik pueda comunicarse con el demonio de Docker y consultarle informaci\u00f3n acerca de los contenedores que est\u00e9n corriendo en ese momento.</p>"},{"location":"proxy-traefik/#configuracion-de-un-servicio","title":"Configuraci\u00f3n de un servicio","text":"<p>Al anterior archivo <code>docker-compose.yaml</code> le a\u00f1adiremos el siguiente servicio:</p> docker-compose.yml<pre><code> whoami:\nimage: \"traefik/whoami\"\ndeploy:\nreplicas: 3 # (4)\nlabels:\n- \"traefik.enable=_______\" #(1)\n- \"traefik.http.routers.whoami.rule=Host(`_______`)\" #(2)\n- \"traefik.http.routers.whoami.entrypoints=_______\" #(3)\nnetworks:\n- red_traefik #(5)\n</code></pre> <ol> <li>Le decimos a Traefik que hay un servicio que queremos exponer</li> <li>Aqu\u00ed especificamos la regla que se debe cumplir para relacionar una petici\u00f3n concreta con este servicio (recuerda cu\u00e1l es nuestro nombre de \"dominio\")</li> <li>Aqu\u00ed le decimos cu\u00e1l de los entrypoint previamente configurados se debe usar para acceder a este servicio </li> <li>Desplegamos 3 instancias del servicio, para poder probar el balanceo de carga</li> <li>Subred a la que pertenecer\u00e1 el contenedor</li> </ol>"},{"location":"proxy-traefik/#configuracion-multiservicio-y-con-coincidencia-de-ruta-patch-matching","title":"Configuraci\u00f3n multiservicio y con coincidencia de ruta (patch matching)","text":"<p>A\u00f1adimos, a continuaci\u00f3n de los anteriores, un nuevo servicio en el fichero <code>yaml</code>:</p> docker-compose.yml<pre><code>  whoami2: #(2)\nimage: \"nginxdemos/hello\" #(1)\ndeploy:\nreplicas: 4 #(3)\nlabels:\n- \"traefik.enable=true\"\n- \"traefik.http.routers.whoami2.rule=Host(`_______`) &amp;&amp; Path(`______`)\" #(4)\n- \"traefik.http.routers.whoami2.entrypoints=web\"\nnetworks:\n- red_traefik #(5)\n</code></pre> <ol> <li>Utilizamos otra imagen de Docker, basada en Nginx que nos mostrar\u00e1 la IP del servidor al que se accede, adem\u00e1s de permitir la recarga autom\u00e1tica. Esto nos facilitar\u00e1 la comprobaci\u00f3n del balanceo de carga.</li> <li>Nombre de este nuevo servicio</li> <li>N\u00famero de instancias a desplegar</li> <li>Queremos que Traefik redirija nuestras peticiones a este servicio cuando accedamos a <code>http://localhost/whoami2</code></li> <li>Subred a la que pertenecer\u00e1 el contenedor</li> </ol> <p>Tarea</p> <p>Comprueba el correcto funcionamiento del escenario:</p> <ol> <li>Accede en tu navegador a <code>http://localhost</code><ul> <li>Recarga varias veces la p\u00e1gina para comprobar que cambia la IP del contenedor y se est\u00e1 produciendo el balanceo de carga.</li> </ul> </li> <li>Accede ahora a <code>http://localhost/whoami2</code>, comprueba que funciona y marca la opci\u00f3n de recargar autom\u00e1ticamente. Comprueba que las peticiones se van repartiendo entre distintos contenedores.</li> </ol> <p>Documenta detalladamente el proceso, indicando exactamente lo que est\u00e1s comprobando.</p>"},{"location":"proxy-traefik/#middleware","title":"Middleware","text":"<p>Tarea</p> <p>Investiga y explica brevemente con tus palabras cu\u00e1l es la funci\u00f3n concreta del middleware en Traefik y lista algunas de sus funciones.</p>"},{"location":"proxy-traefik/#lista-blanca-de-ips","title":"Lista blanca de IPs","text":"<p>En esta parte de la pr\u00e1ctica vamos a hacer uso de esta funci\u00f3n de middleware de Traefik. Fltraremos las IPs de origen que tendr\u00e1n acceso a los servicios de tal forma qu\u00e9:</p> <p></p> <p>Busca informaci\u00f3n sobre c\u00f3mo aplicar el filtrado de IP mediante las listas blancas en Traefik y completa el <code>docker-compose.yml</code> que ya ten\u00edamos con las l\u00edneas resaltadas, as\u00ed como completa los huecos que hagan falta.</p> docker-compose.yml<pre><code> whoami:\nimage: \"traefik/whoami\"\ndeploy:\nreplicas: 3 labels:\n- \"traefik.enable=_______\" - \"traefik.http.routers.whoami.rule=Host(`_______`)\" - \"traefik.http.routers.whoami.entrypoints=_______\" - \"traefik.http.middlewares.whoami-filter-ip.ipwhitelist.__________=___________/24\"\n- \"traefik.http.routers.whoami.middlewares=______________\"\nnetworks:\n- red_traefik\n</code></pre> <p>Tarea</p> <ul> <li>Coloca una lista blanca en el servicio <code>whoami</code> para una direcci\u00f3n de subred diferente a la que estamos utilizando. Comprueba que al intentar acceder, obtienes el <code>403 forbidden</code> que se detalla en el esqumema de la imagen de arriba.</li> <li>De la misma forma, coloca una lista blanca para el servicio <code>whoami2</code> que permite el acceso a la direcci\u00f3n de subred correcta y comprueba que puedes seguir accediendo sin problemas.</li> </ul> <p>Documenta y explica detalladamente el proceso que has seguido para completar el archivo <code>yaml</code>. </p>"},{"location":"proxy-traefik/#autenticacion-basica","title":"Autenticaci\u00f3n b\u00e1sica","text":"<p>Traefik tambi\u00e9n nos ofrece la posibilidad de a\u00f1adir una autenticaci\u00f3n b\u00e1sica al acceso de los distintos servicios.</p> <p>En este caso lo que vamos a hacer es suprimir del primer servicio, de <code>whoami</code> las l\u00edneas que hacen referencia a la lista blanca de IPs y a\u00f1adiremos unas l\u00edneas que proporcionen una autenticaci\u00f3n b\u00e1sica al servicio (la autenticaci\u00f3n):</p> docker-compose.yml<pre><code> whoami:\nimage: \"traefik/whoami\"\nlabels:\n- \"traefik.enable=true\"\n- \"traefik.http.routers.whoami.rule=Host(`__________`)\"\n- \"traefik.http.routers.whoami.entrypoints=_________\"\n- \"traefik.http.middlewares.whoami-auth._____________=raul:$$apr1$$CHKKEQyv$$/Fktitry1Az6rZNYADnDo.\" #(1)\n- \"traefik.http.routers.whoami.middlewares=____________\"\nnetworks:\n- red_traefik\n</code></pre> <ol> <li>Aqu\u00ed debe ir vuestro usuario con vuestra contrase\u00f1a generada, no pong\u00e1is el m\u00edo.</li> </ol> <p>Para generar la contrase\u00f1a, en el terminal pod\u00e9is hacer:</p> <pre><code>echo $(htpasswd -nb vuestro_usuario vuestra_contrase\u00f1a) | sed -e s/\\\\$/\\\\$\\\\$/g\n</code></pre> <p>Para ejecutar este comando en terminal os har\u00e1 falta el paquete apache2-utils, si no lo ten\u00e9is instalado pod\u00e9is hacerlo as\u00ed:</p> <pre><code>sudo apt uptdate &amp;&amp; sudo apt install apache2-utils\n</code></pre> <p>O similar, dependiendo del gestor de paquetes que us\u00e9is.</p> <p>Tarea</p> <ul> <li>Modifica el <code>docker-compose.yml</code> tal y como se indica, rellenando los nuevos huecos de las l\u00edneas resaltadas (los otros dos ya deber\u00edais tenerlos completados de antes). </li> <li>Comprueba que se te solicita autenticaci\u00f3n y que s\u00f3lo eres capaz de acceder con la correcta</li> </ul> <p>Documenta y explica detalladamente el proceso que has seguido para completar el archivo <code>yaml</code>. </p> <p>Tarea</p> <p>Accede al dashboard de Traefik en <code>http://localhost:8080</code> e investiga la informaci\u00f3n mostrada en las distintas secciones. Explica qu\u00e9 significa lo que ves.</p>"},{"location":"proxy-traefik/#para-nota","title":"Para nota","text":"<p>Otra funci\u00f3n que puede realizar nuestro proxy inverso es la de asumir la responsabilidad de los certificados para https de nuestros servicios web, liberando as\u00ed de esa carga a los propios servicios y unificando su administraci\u00f3n en un \u00fanico punto.</p> <p>Tarea para nota</p> <p>Busca informaci\u00f3n sobre c\u00f3mo utilizar certificados autofirmados en Traefik y configuralos para ambos servicios web.</p> <p>Pista</p> <p>Deber\u00e1s generar unos certificados y crear un archivo de configuraci\u00f3n <code>.yml</code> para que Traefik sepa que debe utilizarlos.</p> <p>La primera vez que accedas a ambos servicios por https te saldr\u00e1 un aviso de certificado no confiable, lo cual es normal al estar autofirmado, s\u00f3lo debes aceptar el riesgo.</p> <p>Pregunta</p> <p>\u00bfPor qu\u00e9 si cada vez accedo a un contenedor diferente para cada servicio (recuerda el balanceo de carga) no me vuelve a pedir que acepte el riesgo del certificado cuando accedo a otro nuevo por primera vez?</p>"},{"location":"proxy-traefik/#referencias","title":"Referencias","text":"<p>Documentaci\u00f3n oficial de Traefik</p> <p>El proxy inverso Traefik, caracter\u00edsticas y funcionalidades que ofrece</p> <p>Docker reverse proxy using Traefik</p> <ol> <li> <p>Estos routers son dispositivos situados entre la red interna de y las redes de otros proveedores que intercambian el tr\u00e1fico con nosotros y que se encargan de dirigir el tr\u00e1fico de datos de una lado a otro.\u00a0\u21a9</p> </li> <li> <p>En un escenario real emplearemos nuestro propio dominio, como por ejemplo <code>http://este-es-mi-dominio.es</code>. Sin embargo, puesto que no tenemos ning\u00fan dominio registrado, utilizamos la direcci\u00f3n de nuestro equipo local.\u00a0\u21a9</p> </li> </ol>"},{"location":"proxy/","title":"Configuraci\u00f3 de proxy Squid amb servidor d'autenticaci\u00f3 freeradius en Docker","text":""},{"location":"proxy/#tasques-a-realitzar-i-detalls-de-la-practica","title":"Tasques a realitzar i detalls de la pr\u00e1ctica","text":"<ol> <li>El shared secret \u00e9s una clau compartida entre els clients i el servidor Radius. S'utilitza per a limitar l'\u00fas no autoriztat del servidor d'autenticaci\u00f3. El secret compartit d'esta pr\u00e0ctica \u00e9s invent.</li> <li>Com a contrasenya de root de la BBDD MySQL podeu posar la que m\u00e9s vos agrade.</li> <li>Heu d'omplir els ports a utilitzar per cada servici en el <code>docker-compose.yml</code>(son els ports per defecte del servicis).</li> <li> <p>L'arxiu clients.conf identifica quins dispositius poden comunicarse amb el servidor Radius amb intencions d'autenticar-se, per\u00f2 no realitza l'autenticaci\u00f3. Eixa tasca pertany a l'arxiu users o, en el nostre cas, authorize. </p> <p>Has de crear un usuari en el arxiu clients.conf de Freeradius (el nomb \u00e9s indiferent, nomb\u00e9s serveix per a identificar al client). Mira el diagrama anterior atentament i tingues clar qui demanar\u00e0 l'autoritzaci\u00f3 a Radius</p> </li> <li> <p>A l'inici del fitxer authorize crear un usuari amb autenticaci\u00f3 en text pl\u00e0 (la credencial ser\u00e0 el vostre nom i de contrasenya el cognom). Este arxiu s\u00ed serveix per a l'autenticaci\u00f3</p> </li> <li>Heu d'omplir l'arxiu radius_config de Squid.</li> <li>Afegir una ACL (llista d'acc\u00e9s) que es cride <code>SSL_Ports</code> i que incloga el port 443.</li> <li>Firefox enviar\u00e0 tot el seu tr\u00e0fic (http i https) al port configurat per a Squid. Configurar Firefox per a utilitzar el proxy, tant http, com https (mateix port d'Squid).</li> <li>Quan tot estiga funcionant, baixe-vos e instal\u00b7leu el certificat autogenerat per a que el tr\u00e0fic HTTPS siga completament confiable i no done problemes.</li> <li> <p>Insertar un usuari en la BBDD <code>radius</code> des del contenidor de freeradius, en la taula <code>radcheck</code>. Els valors:</p> <pre><code>username --&gt; Omplir\nattribute --&gt; \"Cleartext-Password\"\nop --&gt; \":=\"\nvalue --&gt; Omplir\n</code></pre> </li> <li> <p>Totes les comprovacions s'han de fer mostrant els logs, tant d'Squid a on es puga veure tots els accesos a Internet que realitzeu, com de Freeradius i a on es mostren ambd\u00f2s autenticacions.</p> </li> </ol> <p>Atenci\u00f3<p>Haur\u00e1s de modificar el <code>radius.conf</code> del contenidor radius per a loguear els intents d'autenticaci\u00f3, tant si s'utilitza un password correcte, com si \u00e9s incorrecte. Donat que no teniu editor de texts en el contenidor, podeu trobar utilitat en aquest comand:</p> <pre><code>sed -i 's/Terme a sustituir/Terme nou/g' arxiu\n</code></pre> </p>"},{"location":"proxy/#contingut-extra-per-a-la-recuperacio-de-la-practica","title":"Contingut extra per a la recuperaci\u00f3 de la pr\u00e0ctica","text":"<p>Per tal de completar la recuperaci\u00f3 d'aquesta pr\u00e0ctica es demana, a m\u00e9s de tot lo anterior:</p> <ol> <li> <p>Configurar Squid per a que bloquegi totes les descarregues majors de 10MB. Podeu comprovar si funciona intentant baixar qualsevol distribuci\u00f3 de Linux.</p> <ul> <li>S'ha de mostrar comprovacions tant del navegador com dels logs.</li> </ul> </li> <li> <p>Configurar Squid per a que bloquegi tot acc\u00e9s a Internet a la IP del client.</p> <ul> <li> <p>S'ha de mostrar comprovacions tant del navegador com dels logs.</p> <p>Consell</p> <p>Configurar el bloqueig abans de que arrive a saltar l'autenticaci\u00f3 del proxy.</p> </li> </ul> </li> </ol>"},{"location":"proxy/#referencies","title":"Refer\u00e8ncies","text":"<p> Configuring a Squid Server to authenticate from RADIUS</p>"},{"location":"vpn/","title":"Servidor de VPN amb wireguard en un escenari muntat amb Docker","text":""},{"location":"vpn/#introduccio","title":"Introducci\u00f3","text":"<p>En aquesta pr\u00e0ctica configurarem un escenari simil\u00b7lar a una infraestructura empresarial real. Tenim un parell d'empleats que treballen a dist\u00e0ncia i necesiten fer \u00fas d'una VPN. Hem evaluat les opcions i, encara que en principi hav\u00edem pensat utilitzar OpenVPN, finalment ens hem decidit per Wireguard amb la possibilitat de, si en un futur tenim m\u00e9s teletreballadors, canviar a OpenVPN.</p> <p>Simularem la nostra infraestructura \u00edntegrament amb contenidors Docker i ser\u00e0 tal que aix\u00ed:</p> <p></p> <p>Els clients establiran un t\u00fanel xifrat amb el servidor de VPN a la DMZ a trav\u00e9s del firewall i aquest servidor, redirigir\u00e0 el tr\u00e0fic ja descifrat a la LAN. El tr\u00e0fic de tornada seguir\u00e0 el cam\u00ed invers.</p> <p>El t\u00fanel s'establir\u00e0 mitjan\u00e7ant UDP i utilitzant el port 51820 entre cada client i el servidor de VPN.</p>"},{"location":"vpn/#tasques-a-realitzar","title":"Tasques a realitzar","text":"<ol> <li>Configurar la VPN per a que els dos clients puguen fer \u00fas d'ella</li> <li>Configurar el servidor VPN per a que assigne IPs d'una subxarxa concreta</li> <li>Comprovar que una vegada establerta la VPN, el tr\u00e0fic viatja xifrat a trav\u00e9s de la WAN i sense xifrar cap a la LAN.</li> <li>Configurar el firewall (iptables) per a permetre les conexions al servidor web i al servidor SSH.</li> </ol>"},{"location":"vpn/#arxiu-docker-composeyml","title":"Arxiu docker-compose.yml","text":"<pre><code>version: '3'\n# Definim les xarxes que tindrem \nnetworks:\nwan:\ndriver: bridge\nipam:\nconfig:\n- subnet: ${WAN}\nlan:\ndriver: bridge\nipam:\nconfig:\n- subnet: ${LAN}\ndmz:\ndriver: bridge\nipam:\nconfig:\n- subnet: ${DMZ}\n# Definim tots els endpoints que formaran part de l'escenari\nservices:\nclient_1:\nbuild:\ncontext: ./dockerfiles\ndockerfile: Dockerfile\ncontainer_name: client1\nhostname: client1\nextra_hosts:\n- \"webserver: ${IP_WEBSERVER}\"\n- \"wireguard: ${IP_WIREGUARD}\"\n- \"sshserver: ${IP_SSHSERVER}\"\nnetworks:\nwan:\nipv4_address: ${IP_CLIENT_1}\ncap_add:\n- NET_ADMIN\nvolumes:\n- ./wireguard:/etc/wireguard\nprivileged: true\ncommand: /bin/bash -c \"echo '1' &gt; /proc/sys/net/ipv4/ip_forward &amp;&amp; ip route del default &amp;&amp; ip route add default via ${IP_FIREWALL_WAN} &amp;&amp; exec sleep infinity\"\nclient_2:\nbuild:\ncontext: ./dockerfiles\ndockerfile: Dockerfile\ncontainer_name: client2\nhostname: client2\nextra_hosts:\n- \"webserver: ${IP_WEBSERVER}\"\n- \"wireguard: ${IP_WIREGUARD}\"\n- \"sshserver: ${IP_SSHSERVER}\"\nnetworks:\nwan:\nipv4_address: ${IP_CLIENT_2}\ncap_add:\n- NET_ADMIN\nprivileged: true\ncommand: /bin/bash -c \"echo '1' &gt; /proc/sys/net/ipv4/ip_forward &amp;&amp; ip route del default &amp;&amp; ip route add default via ${IP_FIREWALL_WAN} &amp;&amp; exec sleep infinity\"\nfirewall:\nbuild:\ncontext: ./dockerfiles\ndockerfile: Dockerfile.firewall\ncontainer_name: firewall\nhostname: firewall\nworking_dir: /usr/local/bin\nextra_hosts:\n- \"client_1: ${IP_CLIENT_1}\"\n- \"client_2: ${IP_CLIENT_2}\"\n- \"webserver: ${IP_WEBSERVER}\"\n- \"sshserver: ${IP_SSHSERVER}\"\n- \"wireguard: ${IP_WIREGUARD}\"   networks:\nwan:\nipv4_address: ${IP_FIREWALL_WAN}\nlan:\nipv4_address: ${IP_FIREWALL_LAN}\ndmz:\nipv4_address: ${IP_FIREWALL_DMZ}\nprivileged: true\ncap_add:\n- NET_ADMIN\nvolumes:\n- ./iptables:/usr/local/bin\ncommand: /bin/bash -c \"echo '1' &gt; /proc/sys/net/ipv4/ip_forward &amp;&amp; ip route del default &amp;&amp; iptables-rules.sh &amp;&amp; exec sleep infinity\"\nwebserver:\nbuild:\ncontext: ./dockerfiles\ndockerfile: Dockerfile.server\ncontainer_name: webserver\nhostname: servidorweb\nextra_hosts:\n- \"client_1: ${IP_CLIENT_1}\"\n- \"client_2: ${IP_CLIENT_2}\"\n- \"sshserver: ${IP_SSHSERVER}\"\n- \"wireguard: ${IP_WIREGUARD}\"   networks:\nlan:\nipv4_address: ${IP_WEBSERVER}\ncap_add:\n- NET_ADMIN\ncommand: /bin/bash -c \"ip route del default &amp;&amp; ip route add default via ${IP_FIREWALL_LAN} &amp;&amp; service nginx start &amp;&amp; exec sleep infinity\"\nssh_server:\nbuild:\ncontext: ./dockerfiles\ndockerfile: Dockerfile.ssh\ncontainer_name: ssh_server\nhostname: ssh_server\nextra_hosts:\n- \"client_1: ${IP_CLIENT_1}\"\n- \"wireguard: ${IP_WIREGUARD}\"\nnetworks:\nlan:\nipv4_address: ${IP_SSHSERVER}\ncap_add:\n- NET_ADMIN\ncommand: /bin/bash -c \"ip route del default &amp;&amp; ip route add default via ${IP_FIREWALL_LAN} &amp;&amp; service ssh start &amp;&amp; exec sleep infinity\"\nrestart: unless-stopped\nwireguard:\nimage: lscr.io/linuxserver/wireguard:latest\ncontainer_name: wireguard\nhostname: wireguard\nextra_hosts:\n- \"client_1: ${IP_CLIENT_1}\"\n- \"server: ${IP_WEBSERVER}\"\nnetworks:\ndmz:\nipv4_address: ${IP_WIREGUARD}\ncap_add:\n- NET_ADMIN\n- SYS_MODULE\ncommand: /bin/bash -c \"apk add tcpdump &amp;&amp; ip route del default &amp;&amp; ip route add default via ${IP_FIREWALL_DMZ} &amp;&amp; exec sleep infinity\"\nenvironment:\n- PUID=1000\n- PGID=1000\n- TZ=Europe/Madrid\n- SERVERURL=\n- SERVERPORT=\n- PEERS=\n- INTERNAL_SUBNET=\n- ALLOWEDIPS=\n- LOG_CONFS=false # No guardar conf en logs\nvolumes:\n- ./volumes/wireguard:/config\n- /lib/modules:/lib/modules\nports:\n- 51820:51820/udp\nsysctls:\n- net.ipv4.conf.all.src_valid_mark=1\n- net.ipv4.conf.all.forwarding=1\nrestart: unless-stopped\n</code></pre> <p>La vostra tasca ser\u00e0 completar les variables d'entorn de les l\u00ednies resaltades del docker-compose.</p> <p>Quan s'inicie l'escenari correctamente, podreu trobar les configuracions de la VPN autogenerades a partir de les variables d'ambient d'aquest docker-compose.yaml en el contenidor de wireguard, en el directori <code>/config</code>. </p> <p>La configuraci\u00f3 del client est\u00e0 dins del directori <code>/config/wg_configs</code> i la dels clients dins de <code>/config/peerX</code>, on la <code>X</code> \u00e9s el n\u00famero de client. Esta configuraci\u00f3 haureu de copiar-la als respectius clients, dins del directori <code>/etc/wireguard</code> amb el nom de <code>wg0.conf</code>.</p> <p>Enlla\u00e7 al repositori</p> <p>Trobareu tot el necessari per a construir l'escenari ac\u00ed: https://github.com/raul-profesor/practica-wireguard-vpn</p> <p>Vos cloneu el repositori amb <code>git clone https://github.com/raul-profesor/practica-wireguard-vpn</code> i podeu comen\u00e7ar a treballar.</p> <p>Podeu consultar el significat de cada variable que heu d'omplir a la p\u00e0gina del contenidor de wireguard o qualsevol altre enlla\u00e7 de les refer\u00e8ncios o Internet.</p> <p>Nota</p> <p>En l'arxiu <code>.env</code> es troben guardades les variables que s'han utilitzat al docker-compose.yml. Podeu ficar les dades que falten al docker-compose de dues formes:   + Posant directament el seu valor on pertoque   + Assignar-li el valor a una variable en l'arxiu <code>.env</code> i posant despr\u00e9s la variable al docker-compose</p>"},{"location":"vpn/#detalls-de-la-vpn","title":"Detalls de la VPN","text":"<p>La informaci\u00f3 relativa a la configuraci\u00f3 de la VPN \u00e9s:</p> <ol> <li>Els clients establiran el t\u00fanel xifrat amb la VPN del servidor</li> <li>El port que faran servir \u00e9s el 51820 UDP</li> <li>Hi hauran dos clients</li> <li>La subxarxa de la VPN ser\u00e0 la <code>192.168.10.0/24</code></li> <li>Les xarxes que s'han d'enrutar seran tant la LAN com la de la VPN</li> </ol> <p>La VPN tindr\u00e1 una subxarxa independent de les altres tres. No obstant, per a que siga funcional, farem que es puga comunicar amb la LAN.</p> <p>A m\u00e9s, existeix un altre concepte que hem de con\u00e8ixer, l'split tunnelling</p> <p>Mentre estigam connectats a la VPN potser que no ens interese que tot el tr\u00e0fic siga encaminat per la VPN, per unes o altres raons. Un cas molt t\u00edpic es quan a trav\u00e9s de la VPN nom\u00e9s es vol donar acc\u00e9s al treballador a recursos interns per\u00f2 no a Internet, per tal de redu\u00efr el consum d'ample de banda de la xarxa de la empresa. \u00c9s a dir, que l'empleat puga accedir a recursos compartits en la xarxa de la empresa amb la VPN per\u00f2 que navegue per Internet amb la seua pr\u00f2pia l\u00ednea d'internet.</p> <p>Un altre cas t\u00edpic:</p> <p></p> <p>Aleshores, en les l\u00ednees del <code>docker-compose.yml</code> que heu d'emplenar, haureu d'indicar-le a la VPN que voleu encaminar pel t\u00fanel xifrat la pr\u00f2pia subsarxa de la VPN i tamb\u00e9 la LAN, per a que puguen comunicar-se entre elles. </p> <p>\u00c9s molt important, principalment per a configurar les regles del firewall, que tingau en compte que el tr\u00e0fic de la VPN segueix el seguent itinerari: client --&gt; t\u00fanel xifrat des dels clients fins al servidor VPN --&gt; servidor VPN fins al dest\u00ed en la LAN. I la tornada del tr\u00e0fic fa exactament el cam\u00ed invers.</p>"},{"location":"vpn/#realitzacio-de-la-practica","title":"Realitzaci\u00f3 de la pr\u00e0ctica","text":"<p>Aix\u00ed les coses, recordem les tasques a realitzar:</p> <p>Tasca 1</p> <p>Fer les configuracions pertinents amb les variables d'entorn del <code>docker-compose.yml</code> per tal d'establir la conexi\u00f3 VPN. </p> <p>Una vegada tingau les configuracions, per a establir el t\u00fanel, dins del contenidor dels clients podem fer en el terminal:</p> <pre><code>wg-quick up wg0\n</code></pre> <p>I comproveu que es crea una interfaz anomenada <code>wg0</code> i que t\u00e9 assignada la IP que l'heu configurat.</p> <p>Tip</p> <p>Fixeu-vos que els contenidors del firewall, wireguard i clients tenen configurat uns volums. Aix\u00f2 vol dir que les modificacions que fem en els arxius del directori local, es voran reflectides en els dels contenidors.</p> <p>Tasca 2</p> <p>Tots els contenidors tenen instal\u00b7lat tcpdump i ho podeu fer servir per a les tasques de troubleshooting.</p> <ul> <li>El que tamb\u00e9 heu de comprovar amb aquesta eina \u00e9s que al accedir al servidor web amb <code>curl http://webserver</code> i al servidor SSH amb <code>ssh sad@sshserver</code> (contrasenya seguretat), amb la VPN sense conectar el tr\u00e0fic viatja utilitzant el protocol TCP i/o sense xifrar.</li> <li>Que quan repetiu l'operaci\u00f3 amb la VPN establerta, el tr\u00e0fic viatja per UDP y xifrat.</li> </ul> <p>Adjunta captura de pantalles \u00f3n es vega clarament la comprovaci\u00f3.</p> <p>Tasca 3</p> <p>Una vegada estiga funcionant perfectament la VPN \u00e9s el torn de configurar el firewall. </p> <ul> <li>Fiqueu un arxiu anomenat <code>iptables-rules.sh</code> en el volum del contenidor del firewall. Aquest arxiu contendr\u00e1, per ordre d'aparici\u00f3:<ul> <li>Neteja de totes les posibles regles que puguen estar configurades previament</li> <li>Escriviu les regles adequades per a que la pol\u00edtica per defecta siga denegar tot el tr\u00e0fic.</li> <li>Afegiu regles per a permetre el tr\u00e1fic pel t\u00fanel VPN cap a la subxarxa LAN i als ports necessaris per als servidors HTTP i SSH.</li> </ul> </li> </ul> <p>Atenci\u00f3</p> <p>Per una questi\u00f3 de seguretat, configureu les regles d'iptables especificant els noms de les interfaces d'entrada, d'eixida i subsarxa dest\u00ed la LAN.</p> <p>Comproveu, adjuntant captures de pantalla, que les regles funcionen perfectament accedint a tots dos servidors i que els contadors de tr\u00e0fic de les regles aumenten quan les mostreu.</p> <p>Tasca 4</p> <p>Una vegada fet tot, prova de llevar de les xarxes que s'enruten per la VPN, la xarxa de la LAN i prova de conectar amb el servidor web i amb el servidor SSH. Qu\u00e8 observes i per qu\u00e8?</p> <p>Tasca 5</p> <p>Com a tasca adicional, intenta configurar l'escenari per a poder accedir pel t\u00fanel VPN (interfaz wg0) al servidor Web per\u00f2 no al servidor SSH. A la mateixa vegada, s'ha de poder accedir per SSH des de l'interfaz WAN al servidor SSH per\u00f2 no al servidor web.</p>"},{"location":"vpn/#contingut-extra-per-a-la-recuperacio-de-la-practica","title":"Contingut extra per a la recuperaci\u00f3 de la pr\u00e0ctica","text":"<p>Per tal de completar la recuperaci\u00f3 d'aquesta pr\u00e0ctica es demana, a m\u00e9s de tot lo anterior configurar un contenidor docker amb la imatge <code>kylemanna/openvpn</code>:</p> <ol> <li>Utilitzeu una m\u00e0quina Linux</li> <li>Com a m\u00e9tode d'autenticaci\u00f3 s'utilitzaran certificats (podeu posar-le contrasenya o no)</li> <li>El Common Name pel certificat ser\u00e0 SAD</li> <li>La IP del servidor a la que ens conectarem ser\u00e0 la de la m\u00e0quina </li> </ol> <p>Atenci\u00f3</p> <ul> <li>S'ha d'explicar i documentar detalladament cada pas que doneu.</li> <li>S'ha de fer la comprovaci\u00f3 de que la VPN funciona:<ul> <li>Conectant des d'un client</li> <li>Mostrant la interfaz creada per a la VPN</li> </ul> </li> <li>\u00bfTens acc\u00e9s a Internet des del client? Independenment de la teua resposta, justifica-la</li> </ul>"},{"location":"vpn/#referencies","title":"Refer\u00e8ncies","text":"<p>Com saber les IP dels contenidors</p> <p>Wireguard docs</p> <p>Wireguard docker documentaci\u00f3</p> <p>How to get started with WireGuard VPN</p> <p>WireGuard Remote Access to Docker Containers</p> <p>Restricciones de puertos e IP\u2019s usando Wireguard</p>"}]}