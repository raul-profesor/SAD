{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"ARP_Spoofing/","title":"ARP Spoofing","text":""},{"location":"ARP_Spoofing/#docker","title":"Docker","text":"<p>https://raul-profesor.github.io/DEAW/introduction/</p> <p>https://kinsta.com/es/base-de-conocimiento/que-es-docker/</p> <p>https://datascientest.com/es/docker-todo-que-saber</p> <p>https://www.ibm.com/topics/docker</p> <p>Tarea 0<p>Deb\u00e9is instalar Docker en Kali o Ubuntu. Pod\u00e9is ayudaros del material que consider\u00e9is, como por ejemplo este o cualquier otro.</p> </p>"},{"location":"ARP_Spoofing/#arp","title":"ARP","text":"<p>Cuando una m\u00e1quina necesita comunicarse con otra en una red, necesita conocer en primera instancia su IP para poder enviar el paquete a su destino, pero en capa 2 de OSI, utiliza direcciones MAC. El protocolo ARP entra en juego en este momento, dado que env\u00eda los mensajes pertinentes para averiguar la direcci\u00f3n MAC asociada a una IP concreta.</p> <p></p> <p>Cuando un dispositivo desea enviar paquetes a otro, lanza un mensaje broadcast ARP preguntando en la red qu\u00e9 disposito posee esa IP concreta y esperando una respuesta \u00fanicamente de ese dispositivo identific\u00e1ndose y, adem\u00e1s, enviando su MAC.</p> <p></p> <p>De esta forma, los dispositivos en la red van construyendo sus tablas ARP, donde cada entrada hace corresponder una IP con su MAC, de tal forma que si tuvieran que volver a enviar mensajes a esas m\u00e1quinas, ya no necesitan pasar por el proceso de averig\u00fcaci\u00f3n de direcciones MAC.</p> <p></p>"},{"location":"ARP_Spoofing/#arp-spoofing","title":"ARP Spoofing","text":"<p>Este ataque es de los conocidos como tipo Man in the Middle, llamados as\u00ed porque consisten en que un atacante o actor malicioso se interpone entre la comnicaci\u00f3n de dos v\u00edctimas, actuando de intermediario sin que ellas se den cuenta. Esto le permite interceptar toda la comunicaci\u00f3n, pudiendo espiarla o incluso modificarla, si as\u00ed lo desea.</p> <p>En el caso de un ARP Spoofing, el atacant env\u00eda falsos mensajes de respuesta ARP, indicando que su MAC se corresponde con otra IP, la de la v\u00edctima y as\u00ed recibir los mensajes que van destinados a ella.</p> <p></p>"},{"location":"ARP_Spoofing/#realizacion-de-la-practica","title":"Realizaci\u00f3n de la pr\u00e1ctica","text":"<p>Deb\u00e9is clonar el repositorio: https://github.com/raul-profesor/spoofing</p> <p>Esta pr\u00e1ctica est\u00e1 ubicada dentro de la carpeta <code>Lab1-ArpSpoofing</code>.</p> <p>Vamos a crear la siguiente infraestructura:</p> <p> </p> <p>Que consiste en:</p> <ul> <li>Dos contenedores v\u00edctimas</li> <li>Un atacante</li> <li>Un observador TcpDumper cuya \u00fanica funci\u00f3n es escuchar el tr\u00e1fico de la red</li> </ul> <p>Pasemos a construir las im\u00e1genes que m\u00e1s tarde dar\u00e1n lugar a los contenedores del atacante y del TcpDumper que vamos a ejecutar. Para este cometido no ten\u00e9is m\u00e1s que ejecutar el <code>script build.sh</code>. Los contenedores v\u00edctimas son simplemente im\u00e1genes de busybox sin modificar, directamente del \"registry\" de Docker.</p> <p>Ahora ejecutaremos los 4 contenedores, cada uno en una pesta\u00f1a distinta del terminal:</p> <pre><code>docker run -it --rm --name box1 busybox\ndocker run -it --rm --name box2 busybox\ndocker run -it --rm --name arpspoofer arpspoofer\ndocker run -it --rm  --net=container:arpspoofer --name tcpdumper tcpdumper\n</code></pre> <p>Tarea 1</p> <ul> <li>Comprueba las IPs y las MAC de box1, box2 y arpspoofer con <code>ip a</code></li> <li>Comprueba la tabla ARP de box1 con <code>watch ip neigh</code></li> <li>Realiza un ping de box2 a box1 y mantenlo</li> <li>En el contenedor del <code>arpspoofer</code> comienza el spoofeo: <code>/usr/sbin/arpspoof -r -i eth0 -t x.x.x.x y.y.y.y</code> (IPs de box1 y 2)</li> </ul> <p>Tras los pasos anteriores deberias empezar a ver el tr\u00e1fico capturado por el contenedor TcpDumper.</p> <p>Tarea 2</p> <p>Adem\u00e1s del tcpdump del contenedor TcpDumper pon a capturar tr\u00e1fico con Wireshark en la interfaz <code>Docker0</code> de la m\u00e1quina anfitri\u00f3n.</p> <p>Tarea 3</p> <p>Describe detalladamente qu\u00e9 observas que est\u00e1 ocurriendo en la captura del contenedor <code>TcpDumper</code></p> <p>Tarea 4</p> <p>\u00bfC\u00f3mo podemos tener una pista de lo que est\u00e1 ocurriendo mirando s\u00f3lamente el <code>ping</code> que hemos lanzado al principio?</p> <p>Tarea 5</p> <p>En la captura de TCPDump, indica y explica detalladamente:     + Mensajes ARP donde se ve claramente qu\u00e9 est\u00e1 ocurriendo y cu\u00e1l es el ataque, ind\u00edca expl\u00edcitamente los mensajes.     + Mensajes ICMP donde se ve la secuencia de los acontecimienntos.</p> <p>Tarea 6</p> <p>En la captura de Wireshark filtra por el protocolo ICMP y repite las explicaciones de la Tarea 5.</p> <p>Tarea 7<p>Realiza un diagrama en https://www.drawio.com/ donde expliques claramente de forma gr\u00e1fica el proceso que has llevado a acabo.</p> </p>"},{"location":"idps/","title":"Monitorizaci\u00f3n mediante sistemas detectores de intrusos (IDS) y sistemas de prevenci\u00f3n de intrusos (IPS)","text":""},{"location":"idps/#introduccion","title":"Introducci\u00f3n","text":"<p>En esta secci\u00f3n vamos a hacer una revisi\u00f3n de los IDS, los IPS y, de refil\u00f3n, de los SIEM.  Se trata de tres herramientas que, aunque parecidas, contribuyen de forma diferente a la protecci\u00f3n de nuestras redes y sistemas. Estamos hablando de unas herramientas de monitorizaci\u00f3n puesto que examinan el tr\u00e1fico que entra y/o sale de nuestra red en b\u00fasqueda de comportamientos sospechosos.</p> <p></p>"},{"location":"idps/#ids","title":"IDS","text":"<p>Son sistemas que monitorizan el tr\u00e1fico entrante y lo cotejan con una base de datos actualizada de firmas de ataque conocidas. Ante cualquier actividad sospechosa, emiten una alerta a los administradores del sistema quienes han de tomar las medidas oportunas. Estos accesos pueden ser ataques espor\u00e1dicos realizados por usuarios malintencionados o repetidos cada cierto tiempo, lanzados con herramientas autom\u00e1ticas. Estos sistemas s\u00f3lo detectan los accesos sospechosos emitiendo alertas anticipatorias de posibles intrusiones, pero no tratan de mitigar la intrusi\u00f3n. Su actuaci\u00f3n es reactiva.</p>"},{"location":"idps/#como-funcionan-los-ids","title":"\u00bfC\u00f3mo funcionan los IDS?","text":"<p>Podemos distinguir dos tipos de IDS:</p> <ol> <li>NIDS (Network-based intrusion detections systems): Monitorizan el tr\u00e1fico de dos formas; o bien configur\u00e1ndolo para que todo el tr\u00e1fico de la red pase a trav\u00e9s de \u00e9l o haciendo un port mirroring.</li> <li>HIDS (Host-based intrusion detections systems): Se configura un sistema para comprobar actividad sospechosa o an\u00f3mala en un host concreto en lugar de en toda la red. Esto limita en gran medida los dipositivos que se monitorizan pero permite detectar con mayor detalle amenazas en ese host.</li> </ol> <p>T\u00edpicamente se utilizan tres metodolog\u00edas para detectar incidentes:</p> <ul> <li> <p>Basada en firmas: compara las firmas con los eventos observados para identificar posibles incidentes. Se trata del m\u00e9todo de detecci\u00f3n m\u00e1s sencillo, ya que compara \u00fanicamente la unidad de actividad actual (como por ejemplo un paquete o una entrada de log) contra una lista de firmas mediante operaciones de comparaci\u00f3n de cadenas.      Estas firmas permiten al IDS distinguir entre el uso normal del PC y el uso fraudulento, y/o entre el tr\u00e1fico normal de la red y el tr\u00e1fico que puede ser resultado de un ataque o intento del mismo y sonpatrones de ataque preconfigurados y predeterminados.</p> <p></p> </li> <li> <p>Detecci\u00f3n basada en anomal\u00edas: compara las definiciones de lo que se considera una actividad normal con los eventos observados para identificar desviaciones significativas. Este m\u00e9todo de detecci\u00f3n puede ser muy eficaz para detectar amenazas desconocidas hasta ahora.</p> <p></p> </li> <li> <p>An\u00e1lisis de protocolos de estado: utiliza informaci\u00f3n sobre las conexiones entre hosts y la compara con las entradas de una tabla de estado. La tabla de estado mantiene un registro de la conexi\u00f3n entre las computadoras que incluye: direcci\u00f3n IP de origen y puerto, direcci\u00f3n IP de destino y puerto, y los protocolos que se utilizan.      Este m\u00e9todo busca cambios repentinos o bruscos en la actividad de la red. Otras funciones incluyen a veces el seguimiento del estado del protocolo, los an\u00e1lisis din\u00e1micos del protocolo de aplicaci\u00f3n y el reensamblaje de paquetes IP, lo que evita que fragmentos de paquetes IP lleguen a la red interna.</p> <p>Entre las ventajas del an\u00e1lisis de protocolo de estado est\u00e1n:</p> <ul> <li>Identifica secuencias inesperadas de comandos.</li> <li>A\u00f1ade caracter\u00edsticas de estado al an\u00e1lisis regular de protocolos.</li> <li>Comprueba la racionalidad de los umbrales de los comandos individuales.</li> </ul> <p>Entre las desventajas est\u00e1n:</p> <ul> <li>Uso intensivo de recursos, sobrecarga de recursos elevada.</li> <li>No puede detectar ataques que no violen las caracter\u00edsticas de comportamiento del protocolo generalmente aceptado.</li> <li>Presenta conflictos entre el modelo de protocolo utilizado por el sistema y c\u00f3mo se implementa realmente el protocolo.</li> </ul> </li> </ul>"},{"location":"idps/#ips","title":"IPS","text":"<p>IPS (Intrusion Prevention System) o sistema de prevenci\u00f3n de intrusiones: es un software que se utiliza para proteger a los sistemas de ataques e intrusiones. Como su nombre indica, su actuaci\u00f3n es de car\u00e1cter preventivo. </p> <p>Estos sistemas llevan a cabo un an\u00e1lisis en tiempo real de las conexiones y los protocolos para determinar si se est\u00e1 produciendo o se va a producir un incidente, identificando ataques seg\u00fan patrones, anomal\u00edas o comportamientos sospechosos y permitiendo el control de acceso a la red, implementando pol\u00edticas que se basan en el contenido del tr\u00e1fico monitorizado, es decir, el IPS adem\u00e1s de lanzar alarmas, puede descartar paquetes y desconectar conexiones.</p> <p></p> <p>Muchos proveedores ofrecen productos mixtos, llam\u00e1ndolos IPS/IDS, integr\u00e1ndose frecuentemente con cortafuegos y UTM (en ingl\u00e9s Unified Threat Management o Gesti\u00f3n Unificada de Amenazas) que controlan el acceso en funci\u00f3n de reglas sobre protocolos y sobre el destino u origen del tr\u00e1fico.</p> <p></p>"},{"location":"idps/#limitaciones-de-de-los-idsips","title":"Limitaciones de de los IDS/IPS","text":"<p>No todo es bonito con estos sistemas, algunos de sus handicaps m\u00e1s importantes son:</p> <ul> <li>Un IDS s\u00f3lo detectar\u00e1 lo que est\u00e9 configurado para detectar. Es decir, est\u00e1n limitados \u00fanicamente a detectar ataques ya conocidos. </li> <li>Son completamente dependientes de las reglas que escribamos o les carguemos y esto lleva inevitablemente a los falsos positivos. Una regla configurada para detectar un ataque tambi\u00e9n puede generar una alerta ante tr\u00e1fico leg\u00edtimo si \u00e9sta no ha sido configurada con sumo cuidado o si el ataque usa un patr\u00f3n com\u00fan de tr\u00e1fico.</li> <li>Capacidades limitadas ante tr\u00e1fico cifrado.</li> <li>Su visibilidad est\u00e1 limitada en funci\u00f3n de d\u00f3nde se coloquen en la red.</li> </ul>"},{"location":"idps/#siem","title":"SIEM","text":"<p>SIEM (Security Information and Event Management) o sistema de gesti\u00f3n de eventos e informaci\u00f3n de seguridad: es una soluci\u00f3n h\u00edbrida centralizada que engloba la gesti\u00f3n de informaci\u00f3n de seguridad (Security Information Management) y la gesti\u00f3n de eventos (Security Event Manager). </p> <p>La tecnolog\u00eda SIEM proporciona un an\u00e1lisis en tiempo real de las alertas de seguridad generadas por los distintos dispositivos hardware y software de la red. Recoge los registros de actividad (logs) de los distintos sistemas, los relaciona y detecta eventos de seguridad, es decir, actividades sospechosas o inesperadas que pueden suponer el inicio de un incidente, descartando los resultados an\u00f3malos, tambi\u00e9n conocidos como falsos positivos y generando respuestas acordes en base a los informes y evaluaciones que registra, es decir, es una herramienta en la que se centraliza la informaci\u00f3n y se integra con otras herramientas de detecci\u00f3n de amenazas.</p> <p></p>"},{"location":"idps/#suricata","title":"Suricata","text":"<p>Suricata es un sistema de detecci\u00f3n de c\u00f3digo abierto que puede actuar tanto como IDS como IPS. Su desarrollo corresponde a Open Information Security Foundation (OSIF). Utiliza un set de reglas y firmas que permite detectar y prevenir amenazas. Puede correr en Windows, Mac, Unix y Linux.</p> <p></p>"},{"location":"idps/#suricata-vs-snort","title":"Suricata vs Snort","text":"<p>Snort es el otro gran actor conocido en el juego de los IDS. Tambi\u00e9n de c\u00f3digo abierto, aunque posee dos sets de reglas principales: las community edition y las de suscriptor. Estas \u00faltimas son de pago y est\u00e1n desarrolladas, probadas y aprobadas por el grupo de seguridad de Cisco, Talos. </p> <p></p> <p>En esencia, Suricata permite acciones por defecto (principalmente relacionadas con la funcionalidad de IPS), que Snort no. No obstante, con una serie de modificaciones es posible hacer que la funcionalidad de Snort pueda ser casi igual, sino igual, a la de Suricata. A\u00fan con todo esto y siempre sin tener en cuenta preferencias personales, podemos destacar algunas ventajas de Suricata:</p> <ul> <li>Trabaja con multithreading. Esto representa una gran ventaja puesto que a d\u00eda de hoy es normal analizar grandes cantidades de tr\u00e1fico que requieren un gran procesado, por lo que sin duda este punto marca una gran diferencia.</li> <li>Es multitenancy. Esto quiere decir que podemos tener diferentes conjuntos de reglas aplic\u00e1ndose al mismo tiempo y asignar cada una de ellas a una VLAN diferente, por ejemplo.</li> <li>Se podr\u00eda decir que el logging de Suricata es de mejor calidad y que permite extraer mayor informaci\u00f3n del tr\u00e1fico que lo atraviesa.</li> <li>Permite utilizar directamente, sin modificaci\u00f3n alguna, las reglas de Snort.</li> </ul> <p>Como todo, siempre hay desventajas o inconvenientes, quiz\u00e1s incluso aplicable a cualquier IDS/IPS:</p> <ul> <li>La configuraci\u00f3n es ardua y dif\u00edcil. Tunearlo hasta que sea realmente \u00fatil puede llegar a ser un aut\u00e9ntico calvario que haga replantearse la utilidad vs esfuerzo.</li> <li>Una de las causas del punto anterior ser\u00eda la gran cantidad de falsos positivos debido a reglas, en ocasiones, demasiado gen\u00e9ricas. Las reglas de pago de Snort por ejemplo mejoran esto en gran medida.</li> <li>Las empresas que se lo pueden permitir econ\u00f3micamente suelen desestimar Suricata en favor de soluciones comerciales como los NGFW (Next Generation Firewalls) o plataformas como las de Fortinet o IBM.</li> <li>Hoy en d\u00eda gran cantidad del tr\u00e1fico va cifrado y el SSL Stripping puede convertirse en un gran problema, ya sea por condiciones de confidencialidad, como por la gran cantidad de recursos que supone de hardware, de adminstraci\u00f3n de endpoints o errores de certificados en los firewalls.</li> </ul>"},{"location":"idps/#demo-y-ejercicios","title":"Demo y ejercicios","text":"<p>Info</p> <p>Para este ejercicio he utilizado una m\u00e1quina virtual Debian 11 Bullseye con la interfaz en modo puente, instalando Suricata desde los repositorios. Si bien Suricata puede instalarse en cualquier distribuci\u00f3n, es posible que necesit\u00e9is algunos pasos adicionales o algo diferentes si utiliz\u00e1is otra.</p> <p>Atenci\u00f3n</p> <p>Todos los comandos de esta demo han sido ejecutados con el usuario root o, en su defecto, usando <code>sudo</code>.</p> <p>En este ejercicio deber\u00e9is llevar a cabo las siguientes acciones:</p> <ol> <li> <p>Instalar Suricata     Hay varias opciones para instalar:</p> <ul> <li>Desde el repositorio de paquetes de la distribuci\u00f3n Linux en concreto</li> <li>Desde un repositorio personal (PPA)</li> <li>Compilando el c\u00f3digo fuente</li> </ul> <p>Yo os recomiendo la primera opci\u00f3n, que siempre es la m\u00e1s sencilla.</p> </li> <li> <p>Configurarlo como IDS</p> <ul> <li>El archivo de configuraci\u00f3n a modificar est\u00e1 en <code>/etc/suricata/suricata.yaml</code></li> <li> <p>Comprobad el nombre de la interfaz de vuestra m\u00e1quina:</p> <p></p> </li> <li> <p>Tras ello, en el archivo de configuraci\u00f3n anterior, colocadlo donde corresponde en la secci\u00f3n <code>af.packet</code> del mismo:   </p> <p></p> </li> <li> <p>Para permitir que Suricata permita una recarga en vivo de las reglas, es decir, que se puedan a\u00f1adir, eliminar y editar las reglas sin la necesidad de reiniciar el proceso de Suricata:    </p> <p></p> <p>Y con este comando le diremos a Suricata que recargue todas las reglas sin reiniciar el proceso:</p> <pre><code>kill -usr2 $(pidof suricata)\n</code></pre> </li> <li> <p>Actualizamos las reglas de Suricata:</p> <pre><code>suricata-update -o /etc/suricata/rules\n</code></pre> </li> <li> <p>Y para validar la configuraci\u00f3n (tardar\u00e1 un poco):     </p> </li> <li> <p>Se inicia el servicio y se comprueba que est\u00e1 activo (tardar\u00e1 un par de minutos en cargar y parsear las reglas):     <pre><code>systemctl start suricata.service\nsystemctl start suricata.service\n</code></pre> </p> </li> </ul> </li> <li> <p>Comprobar que muestra las alertas que detecta de acuerdo a sus reglas</p> <ul> <li> <p>Probaremos la siguiente regla (explicaci\u00f3n del formato de las reglas/firmas):</p> <p></p> <p>Que generar\u00e1 una alarma cuando un posible intruso use el comando <code>id</code> y \u00e9ste responda con root. </p> <p>Para comprobarlo, accederemos a un site que simule este comportamiento ejecutando lo el siguiente comando:</p> <pre><code>curl http://testmynids.org/uid/index.html\n</code></pre> </li> <li> <p>Y examinamos los logs en busca de la alerta, utilizando su identificador:</p> <p></p> <p>Suricata tambi\u00e9n loguea eventos en <code>/var/log/suricata/eve.log</code> usando un formato JSON. La documentaci\u00f3n de Suricata recomienda usar la utilidad <code>jq</code> para leer y filtrar las entradas de este archivo. As\u00ed pues, lo instalamos:</p> <pre><code>apt install jq\n</code></pre> <p>Y buscamos la alerta correspondiente:</p> <pre><code>jq 'select(.alert .signature_id==2100498)' /var/log/suricata/eve.json\n</code></pre> </li> </ul> <p>Tarea</p> <p>Documenta adecuadamente todo este proceso con las capturas de pantalla y las explicaciones pertinentes que demuestren la realizaci\u00f3n y comprobaci\u00f3n del mismo.</p> </li> <li> <p>Configurar Suricata como IPS y comprobar su funcionamiento</p> <p>En este caso vamos a ver como trabajar en capa 3 con el modo inline de Suricata usando <code>iptables</code>. Para ello, necesitamos instalar una dependencia:</p> <pre><code>apt-get -y install libnetfilter-queue-dev\n</code></pre> <p>Ahora haremos que Suricata corra en modo NFQ, o lo que es lo mismo, le decimos que acepte los paquetes que le reenv\u00ede <code>iptables</code> sin que el firewall siga aplicando sus reglas al paquete (es posible que tarde varios minutos):</p> <p><pre><code>suricata -c /etc/suricata/suricata.yaml -q 0\n</code></pre> De la misma forma, debemos decirle al firewall que reenv\u00ede todos los paquete que entran y salen de nuestra m\u00e1quina a Suricata:</p> <pre><code>sudo iptables -I INPUT -j NFQUEUE\nsudo iptables -I OUTPUT -j NFQUEUE\n</code></pre> <p>Podemos ver las reglas activas del firewall con:</p> <pre><code>iptables -vnL\n</code></pre> <p>Por defecto Suricata corre en modo IDS as\u00ed que para activar el IPS haremos:</p> <p><pre><code>systemctl edit suricata.service\n</code></pre> Y a\u00f1adimos las l\u00edneas resaltadas:</p> <pre><code>### Editing /etc/systemd/system/suricata.service.d/override.conf\n### Anything between here and the comment below will become the new contents of the file\n[Service]\nExecStart= \nExecStart=/usr/bin/suricata -c /etc/suricata/suricata.yaml --pidfile /run/suricata.pid -q 0 -vvv\nType=simple\n### Lines below this comment will be discarded\n. . .\n</code></pre> <p>Donde <code>ExecStart=</code> borra el comando por defecto que systemd utiliza para iniciar un servicio. La siguiente l\u00ednea define el nuevo comando a utilizar y <code>Type=simple</code> se asegura de que systemd pueda manejar el proceso de Suricata como cualquier otro servicio cuando est\u00e1 corriendo en modo IPS.</p> <p>Guardamos y reiniciamos systemd para que detecte la nueva configuraci\u00f3n del servicio de Suricata:</p> <pre><code>systemctl daemon-reload\n</code></pre> <p>Reiniciamos Suricata y comprobamos su estado:</p> <pre><code>sudo systemctl restart suricata.service\nsudo systemctl status suricata.service\n</code></pre> <p>Tarea</p> <p>Modifica la regla que hemos comprobado anteriormente para que en lugar de generar una alerta (alert), descarte (drop) los paquetes que hagan match con esa regla.</p> </li> <li> <p>Escribir una regla para el IPS y comprobar que funciona</p> <p>Para este cometido vamos otra vez al archivo de configuraci\u00f3n <code>suricata.yaml</code> y le vamos a indicar que tenga en cuenta un nuevo fichero de reglas/firmas que crearemos m\u00e1s tarde con nuestra regla concreta:</p> <p></p> <p>Tarea</p> <p>A partir de la documentaci\u00f3n proporcionada o de otra que pod\u00e1is encontrar por Internet, escribid una regla de Suricata para que cuando se produzca una conexi\u00f3n desde cualquier IP origen a cualquier IP destino y puerto 8000, el tr\u00e1fico sea bloqueado por <code>iptables</code>.  Ponedle SID 9000001 por ejemplo, para que no haya conflicto con otra regla ya existente. Para comprobarla, en la m\u00e1quina donde est\u00e1 Suricata:</p> <pre><code>nc -nvlp 8000\n</code></pre> <p>Y en la m\u00e1quina anfitriona:</p> <p><pre><code>nc IP_Maq_Virtual 8000\n</code></pre> </p> <p>Nota</p> <p>Recordad el comando para recargar las reglas (puede tardar un rato): <pre><code>kill -USR2 $(pidof suricata)\n</code></pre> Si no os funciona, de acuerdo con la documentaci\u00f3n, probad:</p> <pre><code>suricatasc -c ruleset-reload-nonblocking\n</code></pre> </li> </ol>"},{"location":"idps/#per-a-rocky-linux","title":"Per a Rocky Linux","text":""},{"location":"idps/#ids_1","title":"IDS","text":"<p>Molts m'heu fet saber que no vos ha funcionat la pr\u00e0ctica amb Ubuntu tampoc. En aquest cas, aprofitarem la m\u00e0quina virtual de Rocky Linux, on jo mateix he comprovat que funciona correctament.</p> <p>En primer lloc, per a la instal\u00b7laci\u00f3 i posterior configuraci\u00f3 de Rocky Linux com a IDS, podem seguir el seg\u00fcent tutorial i no les instruccions anteriors, que eren nom\u00e9s per a Debian:</p> <p>How To Install Suricata on Rocky Linux 8</p> <p>On s'explica perfectament com instalar i configurar Suricata, aix\u00ed com la manera de fer la mateixa comprovaci\u00f3 de la regla de Suricata.</p> <p>Si teniu qualsevol problema, comproveu que:</p> <ul> <li>El firewall est\u00e0 desactivat, sin\u00f2 desactiveu-lo: <code>systemctl status firewalld</code></li> <li>Que a l'arxiu de configuraci\u00f3 <code>/etc/suricata/suricata.yml</code> heu canviat en tots els llocs on apareix el nom de la interfaz, per el nom de la vostra</li> <li>Que a l'arxiu <code>/etc/sysconfig/suricata</code> no apareix cap nom d'interfaz que no siga el vostre</li> </ul> <p>Una vegada feta esta part, pasarem a la seg\u00fcent, configurar Suricata com a IPS.</p>"},{"location":"idps/#ips_1","title":"IPS","text":"<p>En aquest cas, ja sabeu que a m\u00e9s d'inspeccionar el tr\u00e0fic, haurem de tallar-lo en cas de trobar activitat sospitosa. </p> <p>Question</p> <p>\u00bfQui pot tallar el tr\u00e0fic de la xarxa? </p> <p>Efectivament, el firewall. Suricata haur\u00e0 de treballar amb el firewall per a fer d'IPS.</p> <p>Podeu seguir qualsevol tutorial, sempre sent conscients de qu\u00e8 esteu fent per favor. Jo vos recomane este: How To Configure Suricata as an Intrusion Prevention System (IPS) on Rocky Linux 8</p> <p>Si llegiu amb atenci\u00f3 el tutorial, \u00e9s en el pas 3 concretament a \u00f3n comen\u00e7a a configurar-se Suricata per a intercontectar-se amb el firewall, aix\u00ed doncs, podeu obviar el passos anteriors.</p> <p>Despr\u00e9s, seguint amb el passos del tutorial, podeu comprobar amb la regla de l'apartat anterior, si canviant el <code>alert</code> per un <code>drop</code> es talla el tr\u00e0fic (haur\u00e0 de donar timeout i haura de vore-se en els logs).</p> <p>Una vegada comprovat que l'IPS funciona, haureu d'escriure ara s\u00ed, una regla pr\u00f2pia a l'arxiu <code>local.rules</code>, tal i com s'explicava en el punt 5 de la pr\u00e1ctica de Debian:</p> <p></p>"},{"location":"idps/#referencias","title":"Referencias","text":"<p>\u00bfQu\u00e9 son y para qu\u00e9 sirven los SIEM, IDS e IPS?</p> <p>Suricata vs snort </p> <p>How to install Suricata in Debian 11</p> <p>How To Install Suricata on Debian 11/Debian 10</p> <p>Suricta User Guide</p>"},{"location":"iptables/","title":"Administraci\u00f3 sencilla de regles d'iptables fent servir Docker","text":""},{"location":"iptables/#introduccio","title":"Introducci\u00f3","text":"<p>Per a simplificar la infraestructra necess\u00e0ria per a esta pr\u00e0ctica, farem servir un framework anomenat Labtainer. Este framework es capa\u00e7 de crear diferents laboratoris o escenaris basats en contenidors de Docker. </p> <p>En concret, el nostre escenari ser\u00e0 tal que aix\u00ed:</p> <p></p>"},{"location":"iptables/#labtainer","title":"Labtainer","text":"<p>Descarregueu la imatge <code>.ova</code> del link que teniu a Aules i importeu-la en Virtualbox.</p> <p>Per tal d'iniciar el laboratori, no tanqueu el terminal s'obrir\u00e0 autom\u00e0ticament i introudiu:</p> <pre><code>labtainer iptables2\n</code></pre> <p>I comen\u00e7aran a desplegar-se els contenidors i se vos obrir\u00e0n dues pestanyes en el terminal del firewall. </p> <p>Nota</p> <p>Quan vos pregunte per l'email, deixeu-lo en blanc i dieu-li que esteu segurs de deixar-lo en blanc <code>(y)</code></p> <p>Per a accedir al terminal de qualsevol contenidor podeu fer servir:</p> <pre><code>docker exec -it &lt;nom_del_contenidor&gt; /bin/bash\n</code></pre>"},{"location":"iptables/#tasques","title":"Tasques","text":"<p>Des del client prova a fer un escaneig de ports al server i comenta el resultats:</p> <pre><code>nmap server\n</code></pre> <p>Prova a accedir per SSH:</p> <pre><code>ssh server\n</code></pre> <p>I confirma que s'oferix el servici de Telnet:</p> <pre><code>telnet server\n</code></pre> <p>Al contenidor firewall est\u00e0 instal\u00b7lat Iptables. Fes-lo servir per a permetre \u00fanicament la redirecci\u00f3 (forwarding) de tr\u00e0fic SSH i HTTP. Per tal d'ajudar-te, pots experimentar amb el script <code>example fw.sh</code>.</p> <p>Atenci\u00f3</p> <p>Considera posar les teues regles d'iptables en un script per tal de poder aplicar-les r\u00e0pidament sempre que ho necessites. </p> <p>Comprova els packets descartats (drop) mirant el logs i assenyalant clarament dins del log on es produeix el drop:</p> <pre><code>tail -f /var/log/iptables.log\n</code></pre> <p>El contenidor firewall tamb\u00e9 t\u00e9 instal\u00b7lada l'aplicaci\u00f3 wireshark, fes-la servir per a vore els drops tamb\u00e9:</p> <pre><code>wireshark &amp;\n</code></pre> <p>Una vegada has limitat el tr\u00e0fic amb iptables, torna a fer el escaneig de ports per a comprovar que la nova situaci\u00f3 \u00e9s correcta.</p>"},{"location":"iptables/#obrir-un-port-per-a-un-nou-servici","title":"Obrir un port per a un nou servici","text":"<p>El contenidor del client inclou un programa anomenat wizbang. Executa este script i comprova quin \u00e9s el port que est\u00e0 intentant utilitzar per a enviar el tr\u00e0fic. </p> <p>Una vegada comprovat, introdueix una regla que permeta este tr\u00e0fic i comprova que funciona correctament (de les dues formes comentades a clase). </p> <p>Fes tamb\u00e9 la comprovaci\u00f3 amb un nou escaneig de ports.</p> <p>Una vegada heu acabat, pareu el laboratori al terminal original amb:</p> <pre><code>stoplab\n</code></pre>"}]}